import {
  __commonJS,
  __require
} from "./chunk-NKHIPFFU.js";

// node_modules/cos-js-sdk-v5/lib/md5.js
var require_md5 = __commonJS({
  "node_modules/cos-js-sdk-v5/lib/md5.js"(exports, module) {
    (function() {
      "use strict";
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_MD5_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_MD5_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [128, 32768, 8388608, -2147483648];
      var SHIFT = [0, 8, 16, 24];
      var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"];
      var BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      var blocks = [], buffer8;
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        buffer8 = new Uint8Array(buffer);
        blocks = new Uint32Array(buffer);
      }
      if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType) {
        return function(message, isBinStr) {
          return new Md5(true).update(message, isBinStr)[outputType]();
        };
      };
      var createMethod = function() {
        var method2 = createOutputMethod("hex");
        if (NODE_JS) {
          method2 = nodeWrap(method2);
        }
        method2.getCtx = method2.create = function() {
          return new Md5();
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method2[type] = createOutputMethod(type);
        }
        return method2;
      };
      var nodeWrap = function(method) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash("md5").update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw ERROR;
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
            return crypto.createHash("md5").update(new Buffer(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      function Md5(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
          this.buffer8 = buffer8;
        } else {
          if (ARRAY_BUFFER) {
            var buffer2 = new ArrayBuffer(68);
            this.buffer8 = new Uint8Array(buffer2);
            this.blocks = new Uint32Array(buffer2);
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
        }
        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      Md5.prototype.update = function(message, isBinStr) {
        if (this.finalized) {
          return;
        }
        var code, index = 0, i, length = message.length, blocks2 = this.blocks;
        var buffer82 = this.buffer8;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = blocks2[16];
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (ARRAY_BUFFER) {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);
              if (isBinStr || code < 128) {
                buffer82[i++] = code;
              } else if (code < 2048) {
                buffer82[i++] = 192 | code >> 6;
                buffer82[i++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                buffer82[i++] = 224 | code >> 12;
                buffer82[i++] = 128 | code >> 6 & 63;
                buffer82[i++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                buffer82[i++] = 240 | code >> 18;
                buffer82[i++] = 128 | code >> 12 & 63;
                buffer82[i++] = 128 | code >> 6 & 63;
                buffer82[i++] = 128 | code & 63;
              }
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);
              if (isBinStr || code < 128) {
                blocks2[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Md5.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[i >> 2] |= EXTRA[i & 3];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = blocks2[16];
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.bytes << 3;
        blocks2[15] = this.hBytes << 3 | this.bytes >>> 29;
        this.hash();
      };
      Md5.prototype.hash = function() {
        var a, b, c, d, bc, da, blocks2 = this.blocks;
        if (this.first) {
          a = blocks2[0] - 680876937;
          a = (a << 7 | a >>> 25) - 271733879 << 0;
          d = (-1732584194 ^ a & 2004318071) + blocks2[1] - 117830708;
          d = (d << 12 | d >>> 20) + a << 0;
          c = (-271733879 ^ d & (a ^ -271733879)) + blocks2[2] - 1126478375;
          c = (c << 17 | c >>> 15) + d << 0;
          b = (a ^ c & (d ^ a)) + blocks2[3] - 1316259209;
          b = (b << 22 | b >>> 10) + c << 0;
        } else {
          a = this.h0;
          b = this.h1;
          c = this.h2;
          d = this.h3;
          a += (d ^ b & (c ^ d)) + blocks2[0] - 680876936;
          a = (a << 7 | a >>> 25) + b << 0;
          d += (c ^ a & (b ^ c)) + blocks2[1] - 389564586;
          d = (d << 12 | d >>> 20) + a << 0;
          c += (b ^ d & (a ^ b)) + blocks2[2] + 606105819;
          c = (c << 17 | c >>> 15) + d << 0;
          b += (a ^ c & (d ^ a)) + blocks2[3] - 1044525330;
          b = (b << 22 | b >>> 10) + c << 0;
        }
        a += (d ^ b & (c ^ d)) + blocks2[4] - 176418897;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks2[5] + 1200080426;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks2[6] - 1473231341;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks2[7] - 45705983;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (d ^ b & (c ^ d)) + blocks2[8] + 1770035416;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks2[9] - 1958414417;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks2[10] - 42063;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks2[11] - 1990404162;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (d ^ b & (c ^ d)) + blocks2[12] + 1804603682;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks2[13] - 40341101;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks2[14] - 1502002290;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks2[15] + 1236535329;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks2[1] - 165796510;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks2[6] - 1069501632;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks2[11] + 643717713;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks2[0] - 373897302;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks2[5] - 701558691;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks2[10] + 38016083;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks2[15] - 660478335;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks2[4] - 405537848;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks2[9] + 568446438;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks2[14] - 1019803690;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks2[3] - 187363961;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks2[8] + 1163531501;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks2[13] - 1444681467;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks2[2] - 51403784;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks2[7] + 1735328473;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks2[12] - 1926607734;
        b = (b << 20 | b >>> 12) + c << 0;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[5] - 378558;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc ^ a) + blocks2[8] - 2022574463;
        d = (d << 11 | d >>> 21) + a << 0;
        da = d ^ a;
        c += (da ^ b) + blocks2[11] + 1839030562;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da ^ c) + blocks2[14] - 35309556;
        b = (b << 23 | b >>> 9) + c << 0;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[1] - 1530992060;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc ^ a) + blocks2[4] + 1272893353;
        d = (d << 11 | d >>> 21) + a << 0;
        da = d ^ a;
        c += (da ^ b) + blocks2[7] - 155497632;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da ^ c) + blocks2[10] - 1094730640;
        b = (b << 23 | b >>> 9) + c << 0;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[13] + 681279174;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc ^ a) + blocks2[0] - 358537222;
        d = (d << 11 | d >>> 21) + a << 0;
        da = d ^ a;
        c += (da ^ b) + blocks2[3] - 722521979;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da ^ c) + blocks2[6] + 76029189;
        b = (b << 23 | b >>> 9) + c << 0;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[9] - 640364487;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc ^ a) + blocks2[12] - 421815835;
        d = (d << 11 | d >>> 21) + a << 0;
        da = d ^ a;
        c += (da ^ b) + blocks2[15] + 530742520;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da ^ c) + blocks2[2] - 995338651;
        b = (b << 23 | b >>> 9) + c << 0;
        a += (c ^ (b | ~d)) + blocks2[0] - 198630844;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks2[7] + 1126891415;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks2[14] - 1416354905;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks2[5] - 57434055;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d)) + blocks2[12] + 1700485571;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks2[3] - 1894986606;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks2[10] - 1051523;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks2[1] - 2054922799;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d)) + blocks2[8] + 1873313359;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks2[15] - 30611744;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks2[6] - 1560198380;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks2[13] + 1309151649;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d)) + blocks2[4] - 145523070;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks2[11] - 1120210379;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks2[2] + 718787259;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks2[9] - 343485551;
        b = (b << 21 | b >>> 11) + c << 0;
        if (this.first) {
          this.h0 = a + 1732584193 << 0;
          this.h1 = b - 271733879 << 0;
          this.h2 = c - 1732584194 << 0;
          this.h3 = d + 271733878 << 0;
          this.first = false;
        } else {
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
        }
      };
      Md5.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
      };
      Md5.prototype.toString = Md5.prototype.hex;
      Md5.prototype.digest = function(format) {
        if (format === "hex")
          return this.hex();
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        var res = [
          h0 & 255,
          h0 >> 8 & 255,
          h0 >> 16 & 255,
          h0 >> 24 & 255,
          h1 & 255,
          h1 >> 8 & 255,
          h1 >> 16 & 255,
          h1 >> 24 & 255,
          h2 & 255,
          h2 >> 8 & 255,
          h2 >> 16 & 255,
          h2 >> 24 & 255,
          h3 & 255,
          h3 >> 8 & 255,
          h3 >> 16 & 255,
          h3 >> 24 & 255
        ];
        return res;
      };
      Md5.prototype.array = Md5.prototype.digest;
      Md5.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(16);
        var blocks2 = new Uint32Array(buffer2);
        blocks2[0] = this.h0;
        blocks2[1] = this.h1;
        blocks2[2] = this.h2;
        blocks2[3] = this.h3;
        return buffer2;
      };
      Md5.prototype.buffer = Md5.prototype.arrayBuffer;
      Md5.prototype.base64 = function() {
        var v1, v2, v3, base64Str = "", bytes = this.array();
        for (var i = 0; i < 15; ) {
          v1 = bytes[i++];
          v2 = bytes[i++];
          v3 = bytes[i++];
          base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] + BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] + BASE64_ENCODE_CHAR[v3 & 63];
        }
        v1 = bytes[i];
        base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[v1 << 4 & 63] + "==";
        return base64Str;
      };
      var exports = createMethod();
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.md5 = exports;
        if (AMD) {
          define(function() {
            return exports;
          });
        }
      }
    })();
  }
});

// node_modules/cos-js-sdk-v5/lib/crypto.js
var require_crypto = __commonJS({
  "node_modules/cos-js-sdk-v5/lib/crypto.js"(exports2, module2) {
    var CryptoJS = CryptoJS || function(g, l) {
      var e = {}, d = e.lib = {}, m = function() {
      }, k = d.Base = { extend: function(a) {
        m.prototype = this;
        var c = new m();
        a && c.mixIn(a);
        c.hasOwnProperty("init") || (c.init = function() {
          c.$super.init.apply(this, arguments);
        });
        c.init.prototype = c;
        c.$super = this;
        return c;
      }, create: function() {
        var a = this.extend();
        a.init.apply(a, arguments);
        return a;
      }, init: function() {
      }, mixIn: function(a) {
        for (var c in a)
          a.hasOwnProperty(c) && (this[c] = a[c]);
        a.hasOwnProperty("toString") && (this.toString = a.toString);
      }, clone: function() {
        return this.init.prototype.extend(this);
      } }, p = d.WordArray = k.extend({ init: function(a, c) {
        a = this.words = a || [];
        this.sigBytes = c != l ? c : 4 * a.length;
      }, toString: function(a) {
        return (a || n).stringify(this);
      }, concat: function(a) {
        var c = this.words, q = a.words, f = this.sigBytes;
        a = a.sigBytes;
        this.clamp();
        if (f % 4)
          for (var b2 = 0; b2 < a; b2++)
            c[f + b2 >>> 2] |= (q[b2 >>> 2] >>> 24 - 8 * (b2 % 4) & 255) << 24 - 8 * ((f + b2) % 4);
        else if (65535 < q.length)
          for (b2 = 0; b2 < a; b2 += 4)
            c[f + b2 >>> 2] = q[b2 >>> 2];
        else
          c.push.apply(c, q);
        this.sigBytes += a;
        return this;
      }, clamp: function() {
        var a = this.words, c = this.sigBytes;
        a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);
        a.length = g.ceil(c / 4);
      }, clone: function() {
        var a = k.clone.call(this);
        a.words = this.words.slice(0);
        return a;
      }, random: function(a) {
        for (var c = [], b2 = 0; b2 < a; b2 += 4)
          c.push(4294967296 * g.random() | 0);
        return new p.init(c, a);
      } }), b = e.enc = {}, n = b.Hex = { stringify: function(a) {
        var c = a.words;
        a = a.sigBytes;
        for (var b2 = [], f = 0; f < a; f++) {
          var d2 = c[f >>> 2] >>> 24 - 8 * (f % 4) & 255;
          b2.push((d2 >>> 4).toString(16));
          b2.push((d2 & 15).toString(16));
        }
        return b2.join("");
      }, parse: function(a) {
        for (var c = a.length, b2 = [], f = 0; f < c; f += 2)
          b2[f >>> 3] |= parseInt(a.substr(
            f,
            2
          ), 16) << 24 - 4 * (f % 8);
        return new p.init(b2, c / 2);
      } }, j = b.Latin1 = { stringify: function(a) {
        var c = a.words;
        a = a.sigBytes;
        for (var b2 = [], f = 0; f < a; f++)
          b2.push(String.fromCharCode(c[f >>> 2] >>> 24 - 8 * (f % 4) & 255));
        return b2.join("");
      }, parse: function(a) {
        for (var c = a.length, b2 = [], f = 0; f < c; f++)
          b2[f >>> 2] |= (a.charCodeAt(f) & 255) << 24 - 8 * (f % 4);
        return new p.init(b2, c);
      } }, h = b.Utf8 = { stringify: function(a) {
        try {
          return decodeURIComponent(escape(j.stringify(a)));
        } catch (c) {
          throw Error("Malformed UTF-8 data");
        }
      }, parse: function(a) {
        return j.parse(unescape(encodeURIComponent(a)));
      } }, r = d.BufferedBlockAlgorithm = k.extend({ reset: function() {
        this._data = new p.init();
        this._nDataBytes = 0;
      }, _append: function(a) {
        "string" == typeof a && (a = h.parse(a));
        this._data.concat(a);
        this._nDataBytes += a.sigBytes;
      }, _process: function(a) {
        var c = this._data, b2 = c.words, f = c.sigBytes, d2 = this.blockSize, e2 = f / (4 * d2), e2 = a ? g.ceil(e2) : g.max((e2 | 0) - this._minBufferSize, 0);
        a = e2 * d2;
        f = g.min(4 * a, f);
        if (a) {
          for (var k2 = 0; k2 < a; k2 += d2)
            this._doProcessBlock(b2, k2);
          k2 = b2.splice(0, a);
          c.sigBytes -= f;
        }
        return new p.init(k2, f);
      }, clone: function() {
        var a = k.clone.call(this);
        a._data = this._data.clone();
        return a;
      }, _minBufferSize: 0 });
      d.Hasher = r.extend({ cfg: k.extend(), init: function(a) {
        this.cfg = this.cfg.extend(a);
        this.reset();
      }, reset: function() {
        r.reset.call(this);
        this._doReset();
      }, update: function(a) {
        this._append(a);
        this._process();
        return this;
      }, finalize: function(a) {
        a && this._append(a);
        return this._doFinalize();
      }, blockSize: 16, _createHelper: function(a) {
        return function(b2, d2) {
          return new a.init(d2).finalize(b2);
        };
      }, _createHmacHelper: function(a) {
        return function(b2, d2) {
          return new s.HMAC.init(
            a,
            d2
          ).finalize(b2);
        };
      } });
      var s = e.algo = {};
      return e;
    }(Math);
    (function() {
      var g = CryptoJS, l = g.lib, e = l.WordArray, d = l.Hasher, m = [], l = g.algo.SHA1 = d.extend({ _doReset: function() {
        this._hash = new e.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
      }, _doProcessBlock: function(d2, e2) {
        for (var b = this._hash.words, n = b[0], j = b[1], h = b[2], g2 = b[3], l2 = b[4], a = 0; 80 > a; a++) {
          if (16 > a)
            m[a] = d2[e2 + a] | 0;
          else {
            var c = m[a - 3] ^ m[a - 8] ^ m[a - 14] ^ m[a - 16];
            m[a] = c << 1 | c >>> 31;
          }
          c = (n << 5 | n >>> 27) + l2 + m[a];
          c = 20 > a ? c + ((j & h | ~j & g2) + 1518500249) : 40 > a ? c + ((j ^ h ^ g2) + 1859775393) : 60 > a ? c + ((j & h | j & g2 | h & g2) - 1894007588) : c + ((j ^ h ^ g2) - 899497514);
          l2 = g2;
          g2 = h;
          h = j << 30 | j >>> 2;
          j = n;
          n = c;
        }
        b[0] = b[0] + n | 0;
        b[1] = b[1] + j | 0;
        b[2] = b[2] + h | 0;
        b[3] = b[3] + g2 | 0;
        b[4] = b[4] + l2 | 0;
      }, _doFinalize: function() {
        var d2 = this._data, e2 = d2.words, b = 8 * this._nDataBytes, g2 = 8 * d2.sigBytes;
        e2[g2 >>> 5] |= 128 << 24 - g2 % 32;
        e2[(g2 + 64 >>> 9 << 4) + 14] = Math.floor(b / 4294967296);
        e2[(g2 + 64 >>> 9 << 4) + 15] = b;
        d2.sigBytes = 4 * e2.length;
        this._process();
        return this._hash;
      }, clone: function() {
        var e2 = d.clone.call(this);
        e2._hash = this._hash.clone();
        return e2;
      } });
      g.SHA1 = d._createHelper(l);
      g.HmacSHA1 = d._createHmacHelper(l);
    })();
    (function() {
      var g = CryptoJS, l = g.enc.Utf8;
      g.algo.HMAC = g.lib.Base.extend({ init: function(e, d) {
        e = this._hasher = new e.init();
        "string" == typeof d && (d = l.parse(d));
        var g2 = e.blockSize, k = 4 * g2;
        d.sigBytes > k && (d = e.finalize(d));
        d.clamp();
        for (var p = this._oKey = d.clone(), b = this._iKey = d.clone(), n = p.words, j = b.words, h = 0; h < g2; h++)
          n[h] ^= 1549556828, j[h] ^= 909522486;
        p.sigBytes = b.sigBytes = k;
        this.reset();
      }, reset: function() {
        var e = this._hasher;
        e.reset();
        e.update(this._iKey);
      }, update: function(e) {
        this._hasher.update(e);
        return this;
      }, finalize: function(e) {
        var d = this._hasher;
        e = d.finalize(e);
        d.reset();
        return d.finalize(this._oKey.clone().concat(e));
      } });
    })();
    (function() {
      var C = CryptoJS;
      var C_lib = C.lib;
      var WordArray = C_lib.WordArray;
      var C_enc = C.enc;
      var Base64 = C_enc.Base64 = {
        stringify: function(wordArray) {
          var words = wordArray.words;
          var sigBytes = wordArray.sigBytes;
          var map = this._map;
          wordArray.clamp();
          var base64Chars = [];
          for (var i = 0; i < sigBytes; i += 3) {
            var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
            var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
            var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
            var triplet = byte1 << 16 | byte2 << 8 | byte3;
            for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
              base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
            }
          }
          var paddingChar = map.charAt(64);
          if (paddingChar) {
            while (base64Chars.length % 4) {
              base64Chars.push(paddingChar);
            }
          }
          return base64Chars.join("");
        },
        parse: function(base64Str) {
          var base64StrLength = base64Str.length;
          var map = this._map;
          var paddingChar = map.charAt(64);
          if (paddingChar) {
            var paddingIndex = base64Str.indexOf(paddingChar);
            if (paddingIndex != -1) {
              base64StrLength = paddingIndex;
            }
          }
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = map.indexOf(base64Str.charAt(i - 1)) << i % 4 * 2;
              var bits2 = map.indexOf(base64Str.charAt(i)) >>> 6 - i % 4 * 2;
              words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
      };
    })();
    if (typeof module2 === "object") {
      module2.exports = CryptoJS;
    } else {
      window.CryptoJS = CryptoJS;
    }
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports2) {
    "use strict";
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      HTML: "text/html",
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      XML_APPLICATION: "application/xml",
      XML_TEXT: "text/xml",
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      HTML: "http://www.w3.org/1999/xhtml",
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      SVG: "http://www.w3.org/2000/svg",
      XML: "http://www.w3.org/XML/1998/namespace",
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports2.assign = assign;
    exports2.freeze = freeze;
    exports2.MIME_TYPE = MIME_TYPE;
    exports2.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports2) {
    var conventions = require_conventions();
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input)
        return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p in src) {
        dest[p] = src[p];
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t2 = function() {
        };
        var t = t2;
        ;
        t2.prototype = Super.prototype;
        t2 = new t2();
        copy(pt, t2);
        Class.prototype = pt = t2;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message)
        this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      length: 0,
      item: function(index) {
        return this[index] || null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc != inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i];
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i < lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i = this.length;
        while (i--) {
          var attr = this[i];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      hasFeature: function(feature, version) {
        return true;
      },
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root2 = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root2);
        }
        return doc;
      },
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        this.insertBefore(newChild, oldChild);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (map[n] == namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (prefix in map) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function _insertBefore(parentNode, newChild, nextChild) {
      var cp = newChild.parentNode;
      if (cp) {
        cp.removeChild(newChild);
      }
      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = newChild.firstChild;
        if (newFirst == null) {
          return newChild;
        }
        var newLast = newChild.lastChild;
      } else {
        newFirst = newLast = newChild;
      }
      var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = nextChild;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parentNode.firstChild = newFirst;
      }
      if (nextChild == null) {
        parentNode.lastChild = newLast;
      } else {
        nextChild.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parentNode;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);
      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
        newChild.firstChild = newChild.lastChild = null;
      }
      return newChild;
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        if (this.documentElement == null && newChild.nodeType == ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return _insertBefore(this, newChild, refChild), newChild.ownerDocument = this, newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);
    function XMLSerializer2() {
    }
    XMLSerializer2.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(
            node.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        var v = node[n];
        if (typeof v != "object") {
          if (v != node2[n]) {
            node2[n] = v;
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e) {
    }
    var getTextContent;
    exports2.DocumentType = DocumentType;
    exports2.DOMException = DOMException;
    exports2.DOMImplementation = DOMImplementation;
    exports2.Element = Element;
    exports2.Node = Node;
    exports2.NodeList = NodeList;
    exports2.XMLSerializer = XMLSerializer2;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports2) {
    var freeze = require_conventions().freeze;
    exports2.XML_ENTITIES = freeze({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' });
    exports2.HTML_ENTITIES = freeze({
      lt: "<",
      gt: ">",
      amp: "&",
      quot: '"',
      apos: "'",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      times: "\xD7",
      divide: "\xF7",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      "int": "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      euro: "\u20AC",
      trade: "\u2122",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    });
    exports2.entityMap = exports2.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports2) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse(
          source,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var k = a2.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k)) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    domBuilder.endPrefixMapping(prefix);
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end++;
              break;
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }
    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(
          qname,
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p = ++start;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p);
              }
              start = p + 1;
              p = source.indexOf(c, start);
              if (p > 0) {
                value = source.slice(start, p);
                addAttribute(attrName, value, start - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
              case S_ATTR_SPACE:
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                value = source.slice(start, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p;
          case "\x80":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            domBuilder.endPrefixMapping(prefix);
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n in source) {
        target[n] = source[n];
      }
    }
    function parseDCC(source, start, domBuilder, errorHandler) {
      var next = source.charAt(start + 2);
      switch (next) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
    };
    function split(source, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1])
          return buf;
      }
    }
    exports2.XMLReader = XMLReader;
    exports2.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports2) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser(options) {
      this.options = options || { locator: {} };
    }
    DOMParser.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax2.parse(
          normalize(source),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l) {
      if (l) {
        return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports2.__DOMHandler = DOMHandler;
    exports2.normalizeLineEndings = normalizeLineEndings;
    exports2.DOMParser = DOMParser;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports2) {
    var dom = require_dom();
    exports2.DOMImplementation = dom.DOMImplementation;
    exports2.XMLSerializer = dom.XMLSerializer;
    exports2.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/cos-js-sdk-v5/lib/xml2json.js
var require_xml2json = __commonJS({
  "node_modules/cos-js-sdk-v5/lib/xml2json.js"(exports2, module2) {
    var DOMParser = require_lib().DOMParser;
    var xmlToJSON = function() {
      this.version = "1.3.5";
      var options = {
        mergeCDATA: true,
        normalize: true,
        stripElemPrefix: true
      };
      var prefixMatch = new RegExp(/(?!xmlns)^.*:/);
      var trimMatch = new RegExp(/^\s+|\s+$/g);
      this.grokType = function(sValue) {
        if (/^\s*$/.test(sValue)) {
          return null;
        }
        if (/^(?:true|false)$/i.test(sValue)) {
          return sValue.toLowerCase() === "true";
        }
        if (isFinite(sValue)) {
          return parseFloat(sValue);
        }
        return sValue;
      };
      this.parseString = function(xmlString, opt) {
        if (xmlString) {
          var xml = this.stringToXML(xmlString);
          if (xml.getElementsByTagName("parsererror").length) {
            return null;
          } else {
            return this.parseXML(xml, opt);
          }
        } else {
          return null;
        }
      };
      this.parseXML = function(oXMLParent, opt) {
        for (var key in opt) {
          options[key] = opt[key];
        }
        var vResult = {}, nLength = 0, sCollectedTxt = "";
        var childNum = oXMLParent.childNodes.length;
        if (childNum) {
          for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {
            oNode = oXMLParent.childNodes.item(nItem);
            if (oNode.nodeType === 4) {
              if (options.mergeCDATA) {
                sCollectedTxt += oNode.nodeValue;
              }
            } else if (oNode.nodeType === 3) {
              sCollectedTxt += oNode.nodeValue;
            } else if (oNode.nodeType === 1) {
              if (nLength === 0) {
                vResult = {};
              }
              if (options.stripElemPrefix) {
                sProp = oNode.nodeName.replace(prefixMatch, "");
              } else {
                sProp = oNode.nodeName;
              }
              vContent = xmlToJSON.parseXML(oNode);
              if (vResult.hasOwnProperty(sProp)) {
                if (vResult[sProp].constructor !== Array) {
                  vResult[sProp] = [vResult[sProp]];
                }
                vResult[sProp].push(vContent);
              } else {
                vResult[sProp] = vContent;
                nLength++;
              }
            }
          }
        }
        if (!Object.keys(vResult).length) {
          vResult = sCollectedTxt || "";
        }
        return vResult;
      };
      this.xmlToString = function(xmlDoc) {
        try {
          var xmlString = xmlDoc.xml ? xmlDoc.xml : new XMLSerializer().serializeToString(xmlDoc);
          return xmlString;
        } catch (err) {
          return null;
        }
      };
      this.stringToXML = function(xmlString) {
        try {
          var xmlDoc = null;
          if (window.DOMParser) {
            var parser = new DOMParser();
            xmlDoc = parser.parseFromString(xmlString, "text/xml");
            return xmlDoc;
          } else {
            xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async = false;
            xmlDoc.loadXML(xmlString);
            return xmlDoc;
          }
        } catch (e) {
          return null;
        }
      };
      return this;
    }.call({});
    var xml2json = function(xmlString) {
      return xmlToJSON.parseString(xmlString);
    };
    module2.exports = xml2json;
  }
});

// node_modules/cos-js-sdk-v5/lib/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/cos-js-sdk-v5/lib/json2xml.js"(exports2, module2) {
    var element_start_char = "a-zA-Z_\xC0-\xD6\xD8-\xF6\xF8-\xFF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FFF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
    var element_non_start_char = "-.0-9\xB7\u0300-\u036F\u203F\u2040";
    var element_replace = new RegExp("^([^" + element_start_char + "])|^((x|X)(m|M)(l|L))|([^" + element_start_char + element_non_start_char + "])", "g");
    var not_safe_in_xml = /[^\x09\x0A\x0D\x20-\xFF\x85\xA0-\uD7FF\uE000-\uFDCF\uFDE0-\uFFFD]/gm;
    var objKeys = function(obj) {
      var l = [];
      if (obj instanceof Object) {
        for (var k in obj) {
          if (obj.hasOwnProperty(k)) {
            l.push(k);
          }
        }
      }
      return l;
    };
    var process_to_xml = function(node_data, options) {
      var makeNode = function(name, content, attributes, level, hasSubNodes) {
        var indent_value = options.indent !== void 0 ? options.indent : "	";
        var indent = options.prettyPrint ? "\n" + new Array(level).join(indent_value) : "";
        if (options.removeIllegalNameCharacters) {
          name = name.replace(element_replace, "_");
        }
        var node = [indent, "<", name, attributes || ""];
        if (content && content.length > 0) {
          node.push(">");
          node.push(content);
          hasSubNodes && node.push(indent);
          node.push("</");
          node.push(name);
          node.push(">");
        } else {
          node.push("/>");
        }
        return node.join("");
      };
      return function fn(node_data2, node_descriptor, level) {
        var type = typeof node_data2;
        if (Array.isArray ? Array.isArray(node_data2) : node_data2 instanceof Array) {
          type = "array";
        } else if (node_data2 instanceof Date) {
          type = "date";
        }
        switch (type) {
          case "array":
            var ret = [];
            node_data2.map(function(v) {
              ret.push(fn(v, 1, level + 1));
            });
            options.prettyPrint && ret.push("\n");
            return ret.join("");
            break;
          case "date":
            return node_data2.toJSON ? node_data2.toJSON() : node_data2 + "";
            break;
          case "object":
            var nodes = [];
            for (var name in node_data2) {
              if (node_data2.hasOwnProperty(name)) {
                if (node_data2[name] instanceof Array) {
                  for (var j = 0; j < node_data2[name].length; j++) {
                    if (node_data2[name].hasOwnProperty(j)) {
                      nodes.push(makeNode(name, fn(node_data2[name][j], 0, level + 1), null, level + 1, objKeys(node_data2[name][j]).length));
                    }
                  }
                } else {
                  nodes.push(makeNode(name, fn(node_data2[name], 0, level + 1), null, level + 1));
                }
              }
            }
            options.prettyPrint && nodes.length > 0 && nodes.push("\n");
            return nodes.join("");
            break;
          case "function":
            return node_data2();
            break;
          default:
            return options.escape ? esc(node_data2) : "" + node_data2;
        }
      }(node_data, 0, 0);
    };
    var xml_header = function(standalone) {
      var ret = ['<?xml version="1.0" encoding="UTF-8"'];
      if (standalone) {
        ret.push(' standalone="yes"');
      }
      ret.push("?>");
      return ret.join("");
    };
    function esc(str) {
      return ("" + str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;").replace(not_safe_in_xml, "");
    }
    module2.exports = function(obj, options) {
      if (!options) {
        options = {
          xmlHeader: {
            standalone: true
          },
          prettyPrint: true,
          indent: "  ",
          escape: true
        };
      }
      if (typeof obj == "string") {
        try {
          obj = JSON.parse(obj.toString());
        } catch (e) {
          return false;
        }
      }
      var xmlheader = "";
      var docType = "";
      if (options) {
        if (typeof options == "object") {
          if (options.xmlHeader) {
            xmlheader = xml_header(!!options.xmlHeader.standalone);
          }
          if (typeof options.docType != "undefined") {
            docType = "<!DOCTYPE " + options.docType + ">";
          }
        } else {
          xmlheader = xml_header();
        }
      }
      options = options || {};
      var ret = [
        xmlheader,
        options.prettyPrint && docType ? "\n" : "",
        docType,
        process_to_xml(obj, options)
      ];
      return ret.join("").replace(/\n{2,}/g, "\n").replace(/\s+$/g, "");
    };
  }
});

// node_modules/cos-js-sdk-v5/src/util.js
var require_util = __commonJS({
  "node_modules/cos-js-sdk-v5/src/util.js"(exports2, module2) {
    "use strict";
    var md5 = require_md5();
    var CryptoJS = require_crypto();
    var xml2json = require_xml2json();
    var json2xml = require_json2xml();
    function camSafeUrlEncode(str) {
      return encodeURIComponent(str).replace(/!/g, "%21").replace(/'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
    }
    function getObjectKeys(obj, forKey) {
      var list = [];
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          list.push(forKey ? camSafeUrlEncode(key).toLowerCase() : key);
        }
      }
      return list.sort(function(a, b) {
        a = a.toLowerCase();
        b = b.toLowerCase();
        return a === b ? 0 : a > b ? 1 : -1;
      });
    }
    var obj2str = function(obj, lowerCaseKey) {
      var i, key, val;
      var list = [];
      var keyList = getObjectKeys(obj);
      for (i = 0; i < keyList.length; i++) {
        key = keyList[i];
        val = obj[key] === void 0 || obj[key] === null ? "" : "" + obj[key];
        key = lowerCaseKey ? camSafeUrlEncode(key).toLowerCase() : camSafeUrlEncode(key);
        val = camSafeUrlEncode(val) || "";
        list.push(key + "=" + val);
      }
      return list.join("&");
    };
    var signHeaders = [
      "content-disposition",
      "content-encoding",
      "content-length",
      "content-md5",
      "expect",
      "host",
      "if-match",
      "if-modified-since",
      "if-none-match",
      "if-unmodified-since",
      "origin",
      "range",
      "response-cache-control",
      "response-content-disposition",
      "response-content-encoding",
      "response-content-language",
      "response-content-type",
      "response-expires",
      "transfer-encoding",
      "versionid"
    ];
    var getSignHeaderObj = function(headers) {
      var signHeaderObj = {};
      for (var i in headers) {
        var key = i.toLowerCase();
        if (key.indexOf("x-cos-") > -1 || signHeaders.indexOf(key) > -1) {
          signHeaderObj[i] = headers[i];
        }
      }
      return signHeaderObj;
    };
    var getAuth = function(opt) {
      opt = opt || {};
      var SecretId = opt.SecretId;
      var SecretKey = opt.SecretKey;
      var KeyTime = opt.KeyTime;
      var method2 = (opt.method || opt.Method || "get").toLowerCase();
      var queryParams = clone(opt.Query || opt.params || {});
      var headers = getSignHeaderObj(clone(opt.Headers || opt.headers || {}));
      var Key = opt.Key || "";
      var pathname;
      if (opt.UseRawKey) {
        pathname = opt.Pathname || opt.pathname || "/" + Key;
      } else {
        pathname = opt.Pathname || opt.pathname || Key;
        pathname.indexOf("/") !== 0 && (pathname = "/" + pathname);
      }
      var forceSignHost = opt.ForceSignHost === false ? false : true;
      if (!headers.Host && !headers.host && opt.Bucket && opt.Region && forceSignHost)
        headers.Host = opt.Bucket + ".cos." + opt.Region + ".myqcloud.com";
      if (!SecretId)
        throw new Error("missing param SecretId");
      if (!SecretKey)
        throw new Error("missing param SecretKey");
      var now = Math.round(getSkewTime(opt.SystemClockOffset) / 1e3) - 1;
      var exp = now;
      var Expires = opt.Expires || opt.expires;
      if (Expires === void 0) {
        exp += 900;
      } else {
        exp += Expires * 1 || 0;
      }
      var qSignAlgorithm = "sha1";
      var qAk = SecretId;
      var qSignTime = KeyTime || now + ";" + exp;
      var qKeyTime = KeyTime || now + ";" + exp;
      var qHeaderList = getObjectKeys(headers, true).join(";").toLowerCase();
      var qUrlParamList = getObjectKeys(queryParams, true).join(";").toLowerCase();
      var signKey = CryptoJS.HmacSHA1(qKeyTime, SecretKey).toString();
      var formatString = [method2, pathname, util.obj2str(queryParams, true), util.obj2str(headers, true), ""].join("\n");
      var stringToSign = ["sha1", qSignTime, CryptoJS.SHA1(formatString).toString(), ""].join("\n");
      var qSignature = CryptoJS.HmacSHA1(stringToSign, signKey).toString();
      var authorization = [
        "q-sign-algorithm=" + qSignAlgorithm,
        "q-ak=" + qAk,
        "q-sign-time=" + qSignTime,
        "q-key-time=" + qKeyTime,
        "q-header-list=" + qHeaderList,
        "q-url-param-list=" + qUrlParamList,
        "q-signature=" + qSignature
      ].join("&");
      return authorization;
    };
    var readIntBE = function(chunk, size, offset) {
      var bytes = size / 8;
      var buf = chunk.slice(offset, offset + bytes);
      new Uint8Array(buf).reverse();
      return new { 8: Uint8Array, 16: Uint16Array, 32: Uint32Array }[size](buf)[0];
    };
    var buf2str = function(chunk, start, end, isUtf8) {
      var buf = chunk.slice(start, end);
      var str = "";
      new Uint8Array(buf).forEach(function(charCode) {
        str += String.fromCharCode(charCode);
      });
      if (isUtf8)
        str = decodeURIComponent(escape(str));
      return str;
    };
    var parseSelectPayload = function(chunk) {
      var header = {};
      var body = buf2str(chunk);
      var result = { records: [] };
      while (chunk.byteLength) {
        var totalLength = readIntBE(chunk, 32, 0);
        var headerLength = readIntBE(chunk, 32, 4);
        var payloadRestLength = totalLength - headerLength - 16;
        var offset = 0;
        var content;
        chunk = chunk.slice(12);
        while (offset < headerLength) {
          var headerNameLength = readIntBE(chunk, 8, offset);
          var headerName = buf2str(chunk, offset + 1, offset + 1 + headerNameLength);
          var headerValueLength = readIntBE(chunk, 16, offset + headerNameLength + 2);
          var headerValue = buf2str(chunk, offset + headerNameLength + 4, offset + headerNameLength + 4 + headerValueLength);
          header[headerName] = headerValue;
          offset += headerNameLength + 4 + headerValueLength;
        }
        if (header[":event-type"] === "Records") {
          content = buf2str(chunk, offset, offset + payloadRestLength, true);
          result.records.push(content);
        } else if (header[":event-type"] === "Stats") {
          content = buf2str(chunk, offset, offset + payloadRestLength, true);
          result.stats = util.xml2json(content).Stats;
        } else if (header[":event-type"] === "error") {
          var errCode = header[":error-code"];
          var errMessage = header[":error-message"];
          var err = new Error(errMessage);
          err.message = errMessage;
          err.name = err.code = errCode;
          result.error = err;
        } else if (["Progress", "Continuation", "End"].includes(header[":event-type"])) {
        }
        chunk = chunk.slice(offset + payloadRestLength + 4);
      }
      return {
        payload: result.records.join(""),
        body
      };
    };
    var getSourceParams = function(source) {
      var parser = this.options.CopySourceParser;
      if (parser)
        return parser(source);
      var m = source.match(/^([^.]+-\d+)\.cos(v6|-cdc)?\.([^.]+)\.myqcloud\.com\/(.+)$/);
      if (!m)
        return null;
      return { Bucket: m[1], Region: m[3], Key: m[4] };
    };
    var noop = function() {
    };
    var clearKey = function(obj) {
      var retObj = {};
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] !== void 0 && obj[key] !== null) {
          retObj[key] = obj[key];
        }
      }
      return retObj;
    };
    var readAsBinaryString = function(blob, callback) {
      var readFun;
      var fr = new FileReader();
      if (FileReader.prototype.readAsBinaryString) {
        readFun = FileReader.prototype.readAsBinaryString;
        fr.onload = function() {
          callback(this.result);
        };
      } else if (FileReader.prototype.readAsArrayBuffer) {
        readFun = function(fileData) {
          var binary = "";
          var pt = this;
          var reader = new FileReader();
          reader.onload = function(e) {
            var bytes = new Uint8Array(reader.result);
            var length = bytes.byteLength;
            for (var i = 0; i < length; i++) {
              binary += String.fromCharCode(bytes[i]);
            }
            callback(binary);
          };
          reader.readAsArrayBuffer(fileData);
        };
      } else {
        console.error("FileReader not support readAsBinaryString");
      }
      readFun.call(fr, blob);
    };
    var fileSliceNeedCopy = function() {
      var compareVersion = function(a, b) {
        a = a.split(".");
        b = b.split(".");
        for (var i = 0; i < b.length; i++) {
          if (a[i] !== b[i]) {
            return parseInt(a[i]) > parseInt(b[i]) ? 1 : -1;
          }
        }
        return 0;
      };
      var check = function(ua) {
        if (!ua)
          return false;
        var ChromeVersion = (ua.match(/Chrome\/([.\d]+)/) || [])[1];
        var QBCoreVersion = (ua.match(/QBCore\/([.\d]+)/) || [])[1];
        var QQBrowserVersion = (ua.match(/QQBrowser\/([.\d]+)/) || [])[1];
        var need = ChromeVersion && compareVersion(ChromeVersion, "53.0.2785.116") < 0 && QBCoreVersion && compareVersion(QBCoreVersion, "3.53.991.400") < 0 && QQBrowserVersion && compareVersion(QQBrowserVersion, "9.0.2524.400") <= 0 || false;
        return need;
      };
      return check(typeof navigator !== "undefined" && navigator.userAgent);
    }();
    var fileSlice = function(file, start, end, isUseToUpload, callback) {
      var blob;
      if (file.slice) {
        blob = file.slice(start, end);
      } else if (file.mozSlice) {
        blob = file.mozSlice(start, end);
      } else if (file.webkitSlice) {
        blob = file.webkitSlice(start, end);
      }
      if (isUseToUpload && fileSliceNeedCopy) {
        var reader = new FileReader();
        reader.onload = function(e) {
          blob = null;
          callback(new Blob([reader.result]));
        };
        reader.readAsArrayBuffer(blob);
      } else {
        callback(blob);
      }
    };
    var getBodyMd5 = function(UploadCheckContentMd5, Body, callback, onProgress) {
      callback = callback || noop;
      if (UploadCheckContentMd5) {
        if (typeof Body === "string") {
          callback(util.md5(Body, true));
        } else if (Blob && Body instanceof Blob) {
          util.getFileMd5(Body, function(err, md52) {
            callback(md52);
          }, onProgress);
        } else {
          callback();
        }
      } else {
        callback();
      }
    };
    var md5ChunkSize = 1024 * 1024;
    var getFileMd5 = function(blob, callback, onProgress) {
      var size = blob.size;
      var loaded = 0;
      var md5ctx = md5.getCtx();
      var next = function(start) {
        if (start >= size) {
          var hash = md5ctx.digest("hex");
          callback(null, hash);
          return;
        }
        var end = Math.min(size, start + md5ChunkSize);
        util.fileSlice(blob, start, end, false, function(chunk) {
          readAsBinaryString(chunk, function(content) {
            chunk = null;
            md5ctx = md5ctx.update(content, true);
            loaded += content.length;
            content = null;
            if (onProgress)
              onProgress({ loaded, total: size, percent: Math.round(loaded / size * 1e4) / 1e4 });
            next(start + md5ChunkSize);
          });
        });
      };
      next(0);
    };
    function clone(obj) {
      return map(obj, function(v) {
        return typeof v === "object" && v !== null ? clone(v) : v;
      });
    }
    function attr(obj, name, defaultValue) {
      return obj && name in obj ? obj[name] : defaultValue;
    }
    function extend(target, source) {
      each(source, function(val, key) {
        target[key] = source[key];
      });
      return target;
    }
    function isArray(arr) {
      return arr instanceof Array;
    }
    function isInArray(arr, item) {
      var flag = false;
      for (var i = 0; i < arr.length; i++) {
        if (item === arr[i]) {
          flag = true;
          break;
        }
      }
      return flag;
    }
    function makeArray(arr) {
      return isArray(arr) ? arr : [arr];
    }
    function each(obj, fn) {
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          fn(obj[i], i);
        }
      }
    }
    function map(obj, fn) {
      var o = isArray(obj) ? [] : {};
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          o[i] = fn(obj[i], i);
        }
      }
      return o;
    }
    function filter(obj, fn) {
      var iaArr = isArray(obj);
      var o = iaArr ? [] : {};
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          if (fn(obj[i], i)) {
            if (iaArr) {
              o.push(obj[i]);
            } else {
              o[i] = obj[i];
            }
          }
        }
      }
      return o;
    }
    var binaryBase64 = function(str) {
      var i, len, char, res = "";
      for (i = 0, len = str.length / 2; i < len; i++) {
        char = parseInt(str[i * 2] + str[i * 2 + 1], 16);
        res += String.fromCharCode(char);
      }
      return btoa(res);
    };
    var uuid = function() {
      var S4 = function() {
        return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
      };
      return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
    };
    var hasMissingParams = function(apiName, params) {
      var Bucket = params.Bucket;
      var Region = params.Region;
      var Key = params.Key;
      var Domain = this.options.Domain;
      var checkBucket = !Domain || typeof Domain === "string" && Domain.indexOf("{Bucket}") > -1;
      var checkRegion = !Domain || typeof Domain === "string" && Domain.indexOf("{Region}") > -1;
      if (apiName.indexOf("Bucket") > -1 || apiName === "deleteMultipleObject" || apiName === "multipartList" || apiName === "listObjectVersions") {
        if (checkBucket && !Bucket)
          return "Bucket";
        if (checkRegion && !Region)
          return "Region";
      } else if (apiName.indexOf("Object") > -1 || apiName.indexOf("multipart") > -1 || apiName === "sliceUploadFile" || apiName === "abortUploadTask") {
        if (checkBucket && !Bucket)
          return "Bucket";
        if (checkRegion && !Region)
          return "Region";
        if (!Key)
          return "Key";
      }
      return false;
    };
    var formatParams = function(apiName, params) {
      params = extend({}, params);
      if (apiName !== "getAuth" && apiName !== "getV4Auth" && apiName !== "getObjectUrl") {
        var Headers = params.Headers || {};
        if (params && typeof params === "object") {
          (function() {
            for (var key in params) {
              if (params.hasOwnProperty(key) && key.indexOf("x-cos-") > -1) {
                Headers[key] = params[key];
              }
            }
          })();
          var headerMap = {
            "x-cos-mfa": "MFA",
            "Content-MD5": "ContentMD5",
            "Content-Length": "ContentLength",
            "Content-Type": "ContentType",
            "Expect": "Expect",
            "Expires": "Expires",
            "Cache-Control": "CacheControl",
            "Content-Disposition": "ContentDisposition",
            "Content-Encoding": "ContentEncoding",
            "Range": "Range",
            "If-Modified-Since": "IfModifiedSince",
            "If-Unmodified-Since": "IfUnmodifiedSince",
            "If-Match": "IfMatch",
            "If-None-Match": "IfNoneMatch",
            "x-cos-copy-source": "CopySource",
            "x-cos-copy-source-Range": "CopySourceRange",
            "x-cos-metadata-directive": "MetadataDirective",
            "x-cos-copy-source-If-Modified-Since": "CopySourceIfModifiedSince",
            "x-cos-copy-source-If-Unmodified-Since": "CopySourceIfUnmodifiedSince",
            "x-cos-copy-source-If-Match": "CopySourceIfMatch",
            "x-cos-copy-source-If-None-Match": "CopySourceIfNoneMatch",
            "x-cos-acl": "ACL",
            "x-cos-grant-read": "GrantRead",
            "x-cos-grant-write": "GrantWrite",
            "x-cos-grant-full-control": "GrantFullControl",
            "x-cos-grant-read-acp": "GrantReadAcp",
            "x-cos-grant-write-acp": "GrantWriteAcp",
            "x-cos-storage-class": "StorageClass",
            "x-cos-traffic-limit": "TrafficLimit",
            "x-cos-mime-limit": "MimeLimit",
            "x-cos-server-side-encryption-customer-algorithm": "SSECustomerAlgorithm",
            "x-cos-server-side-encryption-customer-key": "SSECustomerKey",
            "x-cos-server-side-encryption-customer-key-MD5": "SSECustomerKeyMD5",
            "x-cos-server-side-encryption": "ServerSideEncryption",
            "x-cos-server-side-encryption-cos-kms-key-id": "SSEKMSKeyId",
            "x-cos-server-side-encryption-context": "SSEContext"
          };
          util.each(headerMap, function(paramKey, headerKey) {
            if (params[paramKey] !== void 0) {
              Headers[headerKey] = params[paramKey];
            }
          });
          params.Headers = clearKey(Headers);
        }
      }
      return params;
    };
    var apiWrapper = function(apiName, apiFn) {
      return function(params, callback) {
        var self2 = this;
        if (typeof params === "function") {
          callback = params;
          params = {};
        }
        params = formatParams(apiName, params);
        var formatResult = function(result) {
          if (result && result.headers) {
            result.headers["x-cos-request-id"] && (result.RequestId = result.headers["x-cos-request-id"]);
            result.headers["x-ci-request-id"] && (result.RequestId = result.headers["x-ci-request-id"]);
            result.headers["x-cos-version-id"] && (result.VersionId = result.headers["x-cos-version-id"]);
            result.headers["x-cos-delete-marker"] && (result.DeleteMarker = result.headers["x-cos-delete-marker"]);
          }
          return result;
        };
        var _callback = function(err, data) {
          callback && callback(formatResult(err), formatResult(data));
        };
        var checkParams = function() {
          if (apiName !== "getService" && apiName !== "abortUploadTask") {
            var missingResult = hasMissingParams.call(self2, apiName, params);
            if (missingResult) {
              return "missing param " + missingResult;
            }
            if (params.Region) {
              if (self2.options.CompatibilityMode) {
                if (!/^([a-z\d-.]+)$/.test(params.Region)) {
                  return "Region format error.";
                }
              } else {
                if (params.Region.indexOf("cos.") > -1) {
                  return 'param Region should not be start with "cos."';
                } else if (!/^([a-z\d-]+)$/.test(params.Region)) {
                  return "Region format error.";
                }
              }
              if (!self2.options.CompatibilityMode && params.Region.indexOf("-") === -1 && params.Region !== "yfb" && params.Region !== "default" && params.Region !== "accelerate") {
                console.warn("warning: param Region format error, find help here: https://cloud.tencent.com/document/product/436/6224");
              }
            }
            if (params.Bucket) {
              if (!/^([a-z\d-]+)-(\d+)$/.test(params.Bucket)) {
                if (params.AppId) {
                  params.Bucket = params.Bucket + "-" + params.AppId;
                } else if (self2.options.AppId) {
                  params.Bucket = params.Bucket + "-" + self2.options.AppId;
                } else {
                  return 'Bucket should format as "test-1250000000".';
                }
              }
              if (params.AppId) {
                console.warn('warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g Bucket:"test-1250000000" ).');
                delete params.AppId;
              }
            }
            if (!self2.options.UseRawKey && params.Key && params.Key.substr(0, 1) === "/") {
              params.Key = params.Key.substr(1);
            }
          }
        };
        var errMsg = checkParams();
        var isSync = apiName === "getAuth" || apiName === "getObjectUrl";
        if (typeof Promise === "function" && !isSync && !callback) {
          return new Promise(function(resolve, reject) {
            callback = function(err, data) {
              err ? reject(err) : resolve(data);
            };
            if (errMsg)
              return _callback(util.error(new Error(errMsg)));
            apiFn.call(self2, params, _callback);
          });
        } else {
          if (errMsg)
            return _callback(util.error(new Error(errMsg)));
          var res = apiFn.call(self2, params, _callback);
          if (isSync)
            return res;
        }
      };
    };
    var throttleOnProgress = function(total, onProgress) {
      var self2 = this;
      var size0 = 0;
      var size1 = 0;
      var time0 = Date.now();
      var time1;
      var timer;
      function update() {
        timer = 0;
        if (onProgress && typeof onProgress === "function") {
          time1 = Date.now();
          var speed = Math.max(0, Math.round((size1 - size0) / ((time1 - time0) / 1e3) * 100) / 100) || 0;
          var percent;
          if (size1 === 0 && total === 0) {
            percent = 1;
          } else {
            percent = Math.floor(size1 / total * 100) / 100 || 0;
          }
          time0 = time1;
          size0 = size1;
          try {
            onProgress({ loaded: size1, total, speed, percent });
          } catch (e) {
          }
        }
      }
      return function(info, immediately) {
        if (info) {
          size1 = info.loaded;
          total = info.total;
        }
        if (immediately) {
          clearTimeout(timer);
          update();
        } else {
          if (timer)
            return;
          timer = setTimeout(update, self2.options.ProgressInterval);
        }
      };
    };
    var getFileSize = function(api, params, callback) {
      var size;
      if (typeof params.Body === "string") {
        params.Body = new Blob([params.Body], { type: "text/plain" });
      } else if (params.Body instanceof ArrayBuffer) {
        params.Body = new Blob([params.Body]);
      }
      if (params.Body && (params.Body instanceof Blob || params.Body.toString() === "[object File]" || params.Body.toString() === "[object Blob]")) {
        size = params.Body.size;
      } else {
        callback(util.error(new Error("params body format error, Only allow File|Blob|String.")));
        return;
      }
      params.ContentLength = size;
      callback(null, size);
    };
    var getSkewTime = function(offset) {
      return Date.now() + (offset || 0);
    };
    var error = function(err, opt) {
      var sourceErr = err;
      err.message = err.message || null;
      if (typeof opt === "string") {
        err.error = opt;
        err.message = opt;
      } else if (typeof opt === "object" && opt !== null) {
        extend(err, opt);
        if (opt.code || opt.name)
          err.code = opt.code || opt.name;
        if (opt.message)
          err.message = opt.message;
        if (opt.stack)
          err.stack = opt.stack;
      }
      if (typeof Object.defineProperty === "function") {
        Object.defineProperty(err, "name", { writable: true, enumerable: false });
        Object.defineProperty(err, "message", { enumerable: true });
      }
      err.name = opt && opt.name || err.name || err.code || "Error";
      if (!err.code)
        err.code = err.name;
      if (!err.error)
        err.error = clone(sourceErr);
      return err;
    };
    var isWebWorker = function() {
      return typeof globalThis === "object" && (globalThis.constructor.name === "DedicatedWorkerGlobalScope" || globalThis.FileReaderSync);
    };
    var isNode = function() {
      return typeof window !== "object" && typeof process === "object" && typeof __require === "function" && !isWebWorker();
    };
    var isCIHost = function(url) {
      return /^https?:\/\/([^/]+\.)?ci\.[^/]+/.test(url);
    };
    var util = {
      noop,
      formatParams,
      apiWrapper,
      xml2json,
      json2xml,
      md5,
      clearKey,
      fileSlice,
      getBodyMd5,
      getFileMd5,
      binaryBase64,
      extend,
      isArray,
      isInArray,
      makeArray,
      each,
      map,
      filter,
      clone,
      attr,
      uuid,
      camSafeUrlEncode,
      throttleOnProgress,
      getFileSize,
      getSkewTime,
      error,
      obj2str,
      getAuth,
      parseSelectPayload,
      getSourceParams,
      isBrowser: true,
      isNode,
      isCIHost
    };
    module2.exports = util;
  }
});

// node_modules/cos-js-sdk-v5/src/event.js
var require_event = __commonJS({
  "node_modules/cos-js-sdk-v5/src/event.js"(exports2, module2) {
    var initEvent = function(cos) {
      var listeners = {};
      var getList = function(action) {
        !listeners[action] && (listeners[action] = []);
        return listeners[action];
      };
      cos.on = function(action, callback) {
        if (action === "task-list-update") {
          console.warn('warning: Event "' + action + '" has been deprecated. Please use "list-update" instead.');
        }
        getList(action).push(callback);
      };
      cos.off = function(action, callback) {
        var list = getList(action);
        for (var i = list.length - 1; i >= 0; i--) {
          callback === list[i] && list.splice(i, 1);
        }
      };
      cos.emit = function(action, data) {
        var list = getList(action).map(function(cb) {
          return cb;
        });
        for (var i = 0; i < list.length; i++) {
          list[i](data);
        }
      };
    };
    var EventProxy = function() {
      initEvent(this);
    };
    module2.exports.init = initEvent;
    module2.exports.EventProxy = EventProxy;
  }
});

// node_modules/cos-js-sdk-v5/src/session.js
var require_session = __commonJS({
  "node_modules/cos-js-sdk-v5/src/session.js"(exports2, module2) {
    var util = require_util();
    var cacheKey = "cos_sdk_upload_cache";
    var expires = 30 * 24 * 3600;
    var cache;
    var timer;
    var getCache = function() {
      try {
        var val = JSON.parse(localStorage.getItem(cacheKey));
      } catch (e) {
      }
      if (!val)
        val = [];
      cache = val;
    };
    var setCache = function() {
      try {
        localStorage.setItem(cacheKey, JSON.stringify(cache));
      } catch (e) {
      }
    };
    var init = function() {
      if (cache)
        return;
      getCache.call(this);
      var changed = false;
      var now = Math.round(Date.now() / 1e3);
      for (var i = cache.length - 1; i >= 0; i--) {
        var mtime = cache[i][2];
        if (!mtime || mtime + expires < now) {
          cache.splice(i, 1);
          changed = true;
        }
      }
      changed && setCache();
    };
    var save = function() {
      if (timer)
        return;
      timer = setTimeout(function() {
        setCache();
        timer = null;
      }, 400);
    };
    var mod = {
      using: {},
      setUsing: function(uuid) {
        mod.using[uuid] = true;
      },
      removeUsing: function(uuid) {
        delete mod.using[uuid];
      },
      getFileId: function(file, ChunkSize, Bucket, Key) {
        if (file.name && file.size && file.lastModifiedDate && ChunkSize) {
          return util.md5([file.name, file.size, file.lastModifiedDate, ChunkSize, Bucket, Key].join("::"));
        } else {
          return null;
        }
      },
      getUploadIdList: function(uuid) {
        if (!uuid)
          return null;
        init.call(this);
        var list = [];
        for (var i = 0; i < cache.length; i++) {
          if (cache[i][0] === uuid)
            list.push(cache[i][1]);
        }
        return list.length ? list : null;
      },
      saveUploadId: function(uuid, UploadId, limit) {
        init.call(this);
        if (!uuid)
          return;
        for (var i = cache.length - 1; i >= 0; i--) {
          var item = cache[i];
          if (item[0] === uuid && item[1] === UploadId) {
            cache.splice(i, 1);
          }
        }
        cache.unshift([uuid, UploadId, Math.round(Date.now() / 1e3)]);
        if (cache.length > limit)
          cache.splice(limit);
        save();
      },
      removeUploadId: function(UploadId) {
        init.call(this);
        delete mod.using[UploadId];
        for (var i = cache.length - 1; i >= 0; i--) {
          if (cache[i][1] === UploadId)
            cache.splice(i, 1);
        }
        save();
      }
    };
    module2.exports = mod;
  }
});

// node_modules/cos-js-sdk-v5/src/task.js
var require_task = __commonJS({
  "node_modules/cos-js-sdk-v5/src/task.js"(exports2, module2) {
    var session = require_session();
    var util = require_util();
    var originApiMap = {};
    var transferToTaskMethod = function(apiMap, apiName) {
      originApiMap[apiName] = apiMap[apiName];
      apiMap[apiName] = function(params, callback) {
        if (params.SkipTask) {
          originApiMap[apiName].call(this, params, callback);
        } else {
          this._addTask(apiName, params, callback);
        }
      };
    };
    var initTask = function(cos) {
      var queue = [];
      var tasks = {};
      var uploadingFileCount = 0;
      var nextUploadIndex = 0;
      var formatTask = function(task) {
        var t = {
          id: task.id,
          Bucket: task.Bucket,
          Region: task.Region,
          Key: task.Key,
          FilePath: task.FilePath,
          state: task.state,
          loaded: task.loaded,
          size: task.size,
          speed: task.speed,
          percent: task.percent,
          hashPercent: task.hashPercent,
          error: task.error
        };
        if (task.FilePath)
          t.FilePath = task.FilePath;
        if (task._custom)
          t._custom = task._custom;
        return t;
      };
      var emitListUpdate = function() {
        var timer;
        var emit = function() {
          timer = 0;
          cos.emit("task-list-update", { list: util.map(queue, formatTask) });
          cos.emit("list-update", { list: util.map(queue, formatTask) });
        };
        return function() {
          if (!timer)
            timer = setTimeout(emit);
        };
      }();
      var clearQueue = function() {
        if (queue.length <= cos.options.UploadQueueSize)
          return;
        for (var i = 0; i < nextUploadIndex && i < queue.length && queue.length > cos.options.UploadQueueSize; ) {
          var isActive = queue[i].state === "waiting" || queue[i].state === "checking" || queue[i].state === "uploading";
          if (!queue[i] || !isActive) {
            tasks[queue[i].id] && delete tasks[queue[i].id];
            queue.splice(i, 1);
            nextUploadIndex--;
          } else {
            i++;
          }
        }
        emitListUpdate();
      };
      var startNextTask = function() {
        if (uploadingFileCount >= cos.options.FileParallelLimit)
          return;
        while (queue[nextUploadIndex] && queue[nextUploadIndex].state !== "waiting")
          nextUploadIndex++;
        if (nextUploadIndex >= queue.length)
          return;
        var task = queue[nextUploadIndex];
        nextUploadIndex++;
        uploadingFileCount++;
        task.state = "checking";
        task.params.onTaskStart && task.params.onTaskStart(formatTask(task));
        !task.params.UploadData && (task.params.UploadData = {});
        var apiParams = util.formatParams(task.api, task.params);
        originApiMap[task.api].call(cos, apiParams, function(err, data) {
          if (!cos._isRunningTask(task.id))
            return;
          if (task.state === "checking" || task.state === "uploading") {
            task.state = err ? "error" : "success";
            err && (task.error = err);
            uploadingFileCount--;
            emitListUpdate();
            startNextTask();
            task.callback && task.callback(err, data);
            if (task.state === "success") {
              if (task.params) {
                delete task.params.UploadData;
                delete task.params.Body;
                delete task.params;
              }
              delete task.callback;
            }
          }
          clearQueue();
        });
        emitListUpdate();
        setTimeout(startNextTask);
      };
      var killTask = function(id, switchToState) {
        var task = tasks[id];
        if (!task)
          return;
        var waiting = task && task.state === "waiting";
        var running = task && (task.state === "checking" || task.state === "uploading");
        if (switchToState === "canceled" && task.state !== "canceled" || switchToState === "paused" && waiting || switchToState === "paused" && running) {
          if (switchToState === "paused" && task.params.Body && typeof task.params.Body.pipe === "function") {
            console.error("stream not support pause");
            return;
          }
          task.state = switchToState;
          cos.emit("inner-kill-task", { TaskId: id, toState: switchToState });
          try {
            var UploadId = task && task.params && task.params.UploadData.UploadId;
          } catch (e) {
          }
          if (switchToState === "canceled" && UploadId)
            session.removeUsing(UploadId);
          emitListUpdate();
          if (running) {
            uploadingFileCount--;
            startNextTask();
          }
          if (switchToState === "canceled") {
            if (task.params) {
              delete task.params.UploadData;
              delete task.params.Body;
              delete task.params;
            }
            delete task.callback;
          }
        }
        clearQueue();
      };
      cos._addTasks = function(taskList) {
        util.each(taskList, function(task) {
          cos._addTask(task.api, task.params, task.callback, true);
        });
        emitListUpdate();
      };
      var isTaskReadyWarning = true;
      cos._addTask = function(api, params, callback, ignoreAddEvent) {
        params = util.formatParams(api, params);
        var id = util.uuid();
        params.TaskId = id;
        params.onTaskReady && params.onTaskReady(id);
        if (params.TaskReady) {
          params.TaskReady(id);
          isTaskReadyWarning && console.warn('warning: Param "TaskReady" has been deprecated. Please use "onTaskReady" instead.');
          isTaskReadyWarning = false;
        }
        var task = {
          params,
          callback,
          api,
          index: queue.length,
          id,
          Bucket: params.Bucket,
          Region: params.Region,
          Key: params.Key,
          FilePath: params.FilePath || "",
          state: "waiting",
          loaded: 0,
          size: 0,
          speed: 0,
          percent: 0,
          hashPercent: 0,
          error: null,
          _custom: params._custom
        };
        var onHashProgress = params.onHashProgress;
        params.onHashProgress = function(info) {
          if (!cos._isRunningTask(task.id))
            return;
          task.hashPercent = info.percent;
          onHashProgress && onHashProgress(info);
          emitListUpdate();
        };
        var onProgress = params.onProgress;
        params.onProgress = function(info) {
          if (!cos._isRunningTask(task.id))
            return;
          task.state === "checking" && (task.state = "uploading");
          task.loaded = info.loaded;
          task.speed = info.speed;
          task.percent = info.percent;
          onProgress && onProgress(info);
          emitListUpdate();
        };
        util.getFileSize(api, params, function(err, size) {
          if (err)
            return callback(util.error(err));
          tasks[id] = task;
          queue.push(task);
          task.size = size;
          !ignoreAddEvent && emitListUpdate();
          startNextTask();
          clearQueue();
        });
        return id;
      };
      cos._isRunningTask = function(id) {
        var task = tasks[id];
        return !!(task && (task.state === "checking" || task.state === "uploading"));
      };
      cos.getTaskList = function() {
        return util.map(queue, formatTask);
      };
      cos.cancelTask = function(id) {
        killTask(id, "canceled");
      };
      cos.pauseTask = function(id) {
        killTask(id, "paused");
      };
      cos.restartTask = function(id) {
        var task = tasks[id];
        if (task && (task.state === "paused" || task.state === "error")) {
          task.state = "waiting";
          emitListUpdate();
          nextUploadIndex = Math.min(nextUploadIndex, task.index);
          startNextTask();
        }
      };
      cos.isUploadRunning = function() {
        return uploadingFileCount || nextUploadIndex < queue.length;
      };
    };
    module2.exports.transferToTaskMethod = transferToTaskMethod;
    module2.exports.init = initTask;
  }
});

// node_modules/cos-js-sdk-v5/lib/request.js
var require_request = __commonJS({
  "node_modules/cos-js-sdk-v5/lib/request.js"(exports2, module2) {
    var stringifyPrimitive = function(v) {
      switch (typeof v) {
        case "string":
          return v;
        case "boolean":
          return v ? "true" : "false";
        case "number":
          return isFinite(v) ? v : "";
        default:
          return "";
      }
    };
    var queryStringify = function(obj, sep, eq, name) {
      sep = sep || "&";
      eq = eq || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return Object.keys(obj).map(function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (Array.isArray(obj[k])) {
            return obj[k].map(function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).filter(Boolean).join(sep);
      }
      if (!name)
        return "";
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
    var xhrRes = function(err, xhr, body) {
      var headers = {};
      xhr.getAllResponseHeaders().trim().split("\n").forEach(function(item) {
        if (item) {
          var index = item.indexOf(":");
          var key = item.substr(0, index).trim().toLowerCase();
          var val = item.substr(index + 1).trim();
          headers[key] = val;
        }
      });
      return {
        error: err,
        statusCode: xhr.status,
        statusMessage: xhr.statusText,
        headers,
        body
      };
    };
    var xhrBody = function(xhr, dataType) {
      return !dataType && dataType === "text" ? xhr.responseText : xhr.response;
    };
    var request = function(opt, callback) {
      var method2 = (opt.method || "GET").toUpperCase();
      var url = opt.url;
      if (opt.qs) {
        var qsStr = queryStringify(opt.qs);
        if (qsStr) {
          url += (url.indexOf("?") === -1 ? "?" : "&") + qsStr;
        }
      }
      var xhr = new XMLHttpRequest();
      xhr.open(method2, url, true);
      xhr.responseType = opt.dataType || "text";
      if (opt.xhrFields) {
        for (var xhrField in opt.xhrFields) {
          xhr[xhrField] = opt.xhrFields[xhrField];
        }
      }
      var headers = opt.headers;
      if (headers) {
        for (var key in headers) {
          if (headers.hasOwnProperty(key) && key.toLowerCase() !== "content-length" && key.toLowerCase() !== "user-agent" && key.toLowerCase() !== "origin" && key.toLowerCase() !== "host") {
            xhr.setRequestHeader(key, headers[key]);
          }
        }
      }
      if (opt.onProgress && xhr.upload)
        xhr.upload.onprogress = opt.onProgress;
      if (opt.onDownloadProgress)
        xhr.onprogress = opt.onDownloadProgress;
      if (opt.timeout)
        xhr.timeout = opt.timeout;
      xhr.ontimeout = function(event) {
        var error = new Error("timeout");
        callback(xhrRes(error, xhr));
      };
      xhr.onload = function() {
        callback(xhrRes(null, xhr, xhrBody(xhr, opt.dataType)));
      };
      xhr.onerror = function(err) {
        var body = xhrBody(xhr, opt.dataType);
        if (body) {
          callback(xhrRes(null, xhr, body));
        } else {
          var error = xhr.statusText;
          if (!error && xhr.status === 0)
            error = new Error("CORS blocked or network error");
          callback(xhrRes(error, xhr, body));
        }
      };
      xhr.send(opt.body || "");
      return xhr;
    };
    module2.exports = request;
  }
});

// node_modules/cos-js-sdk-v5/src/base.js
var require_base = __commonJS({
  "node_modules/cos-js-sdk-v5/src/base.js"(exports2, module2) {
    var REQUEST = require_request();
    var util = require_util();
    function getService(params, callback) {
      if (typeof params === "function") {
        callback = params;
        params = {};
      }
      var protocol = this.options.Protocol || (util.isBrowser && location.protocol === "http:" ? "http:" : "https:");
      var domain = this.options.ServiceDomain;
      var appId = params.AppId || this.options.appId;
      var region = params.Region;
      if (domain) {
        domain = domain.replace(/\{\{AppId\}\}/ig, appId || "").replace(/\{\{Region\}\}/ig, region || "").replace(/\{\{.*?\}\}/ig, "");
        if (!/^[a-zA-Z]+:\/\//.test(domain)) {
          domain = protocol + "//" + domain;
        }
        if (domain.slice(-1) === "/") {
          domain = domain.slice(0, -1);
        }
      } else if (region) {
        domain = protocol + "//cos." + region + ".myqcloud.com";
      } else {
        domain = protocol + "//service.cos.myqcloud.com";
      }
      var SignHost = "";
      var standardHost = region ? "cos." + region + ".myqcloud.com" : "service.cos.myqcloud.com";
      var urlHost = domain.replace(/^https?:\/\/([^/]+)(\/.*)?$/, "$1");
      if (standardHost === urlHost)
        SignHost = standardHost;
      submitRequest.call(this, {
        Action: "name/cos:GetService",
        url: domain,
        method: "GET",
        headers: params.Headers,
        SignHost
      }, function(err, data) {
        if (err)
          return callback(err);
        var buckets = data && data.ListAllMyBucketsResult && data.ListAllMyBucketsResult.Buckets && data.ListAllMyBucketsResult.Buckets.Bucket || [];
        buckets = util.isArray(buckets) ? buckets : [buckets];
        var owner = data && data.ListAllMyBucketsResult && data.ListAllMyBucketsResult.Owner || {};
        callback(null, {
          Buckets: buckets,
          Owner: owner,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putBucket(params, callback) {
      var self2 = this;
      var xml = "";
      if (params["BucketAZConfig"]) {
        var CreateBucketConfiguration = {
          BucketAZConfig: params.BucketAZConfig
        };
        xml = util.json2xml({ CreateBucketConfiguration });
      }
      submitRequest.call(this, {
        Action: "name/cos:PutBucket",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        body: xml
      }, function(err, data) {
        if (err)
          return callback(err);
        var url = getUrl({
          protocol: self2.options.Protocol,
          domain: self2.options.Domain,
          bucket: params.Bucket,
          region: params.Region,
          isLocation: true
        });
        callback(null, {
          Location: url,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function headBucket(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:HeadBucket",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        method: "HEAD"
      }, callback);
    }
    function getBucket(params, callback) {
      var reqParams = {};
      reqParams["prefix"] = params["Prefix"] || "";
      reqParams["delimiter"] = params["Delimiter"];
      reqParams["marker"] = params["Marker"];
      reqParams["max-keys"] = params["MaxKeys"];
      reqParams["encoding-type"] = params["EncodingType"];
      submitRequest.call(this, {
        Action: "name/cos:GetBucket",
        ResourceKey: reqParams["prefix"],
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        qs: reqParams
      }, function(err, data) {
        if (err)
          return callback(err);
        var ListBucketResult = data.ListBucketResult || {};
        var Contents = ListBucketResult.Contents || [];
        var CommonPrefixes = ListBucketResult.CommonPrefixes || [];
        Contents = util.isArray(Contents) ? Contents : [Contents];
        CommonPrefixes = util.isArray(CommonPrefixes) ? CommonPrefixes : [CommonPrefixes];
        var result = util.clone(ListBucketResult);
        util.extend(result, {
          Contents,
          CommonPrefixes,
          statusCode: data.statusCode,
          headers: data.headers
        });
        callback(null, result);
      });
    }
    function deleteBucket(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteBucket",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        method: "DELETE"
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putBucketAcl(params, callback) {
      var headers = params.Headers;
      var xml = "";
      if (params["AccessControlPolicy"]) {
        var AccessControlPolicy = util.clone(params["AccessControlPolicy"] || {});
        var Grants = AccessControlPolicy.Grants || AccessControlPolicy.Grant;
        Grants = util.isArray(Grants) ? Grants : [Grants];
        delete AccessControlPolicy.Grant;
        delete AccessControlPolicy.Grants;
        AccessControlPolicy.AccessControlList = { Grant: Grants };
        xml = util.json2xml({ AccessControlPolicy });
        headers["Content-Type"] = "application/xml";
        headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      }
      util.each(headers, function(val, key) {
        if (key.indexOf("x-cos-grant-") === 0) {
          headers[key] = uniqGrant(headers[key]);
        }
      });
      submitRequest.call(this, {
        Action: "name/cos:PutBucketACL",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        headers,
        action: "acl",
        body: xml
      }, function(err, data) {
        if (err)
          return callback(err);
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketAcl(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketACL",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "acl"
      }, function(err, data) {
        if (err)
          return callback(err);
        var AccessControlPolicy = data.AccessControlPolicy || {};
        var Owner = AccessControlPolicy.Owner || {};
        var Grant = AccessControlPolicy.AccessControlList.Grant || [];
        Grant = util.isArray(Grant) ? Grant : [Grant];
        var result = decodeAcl(AccessControlPolicy);
        if (data.headers && data.headers["x-cos-acl"]) {
          result.ACL = data.headers["x-cos-acl"];
        }
        result = util.extend(result, {
          Owner,
          Grants: Grant,
          statusCode: data.statusCode,
          headers: data.headers
        });
        callback(null, result);
      });
    }
    function putBucketCors(params, callback) {
      var CORSConfiguration = params["CORSConfiguration"] || {};
      var CORSRules = CORSConfiguration["CORSRules"] || params["CORSRules"] || [];
      CORSRules = util.clone(util.isArray(CORSRules) ? CORSRules : [CORSRules]);
      util.each(CORSRules, function(rule) {
        util.each(["AllowedOrigin", "AllowedHeader", "AllowedMethod", "ExposeHeader"], function(key) {
          var sKey = key + "s";
          var val = rule[sKey] || rule[key] || [];
          delete rule[sKey];
          rule[key] = util.isArray(val) ? val : [val];
        });
      });
      var Conf = { CORSRule: CORSRules };
      if (params.ResponseVary)
        Conf.ResponseVary = params.ResponseVary;
      var xml = util.json2xml({ CORSConfiguration: Conf });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketCORS",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "cors",
        headers
      }, function(err, data) {
        if (err)
          return callback(err);
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketCors(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketCORS",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "cors"
      }, function(err, data) {
        if (err) {
          if (err.statusCode === 404 && err.error && err.error.Code === "NoSuchCORSConfiguration") {
            var result = {
              CORSRules: [],
              statusCode: err.statusCode
            };
            err.headers && (result.headers = err.headers);
            callback(null, result);
          } else {
            callback(err);
          }
          return;
        }
        var CORSConfiguration = data.CORSConfiguration || {};
        var CORSRules = CORSConfiguration.CORSRules || CORSConfiguration.CORSRule || [];
        CORSRules = util.clone(util.isArray(CORSRules) ? CORSRules : [CORSRules]);
        var ResponseVary = CORSConfiguration.ResponseVary;
        util.each(CORSRules, function(rule) {
          util.each(["AllowedOrigin", "AllowedHeader", "AllowedMethod", "ExposeHeader"], function(key) {
            var sKey = key + "s";
            var val = rule[sKey] || rule[key] || [];
            delete rule[key];
            rule[sKey] = util.isArray(val) ? val : [val];
          });
        });
        callback(null, {
          CORSRules,
          ResponseVary,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function deleteBucketCors(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteBucketCORS",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "cors"
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode || err.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketLocation(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketLocation",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "location"
      }, callback);
    }
    function putBucketPolicy(params, callback) {
      var Policy = params["Policy"];
      try {
        if (typeof Policy === "string")
          Policy = JSON.parse(Policy);
      } catch (e) {
      }
      if (!Policy || typeof Policy === "string")
        return callback(util.error(new Error("Policy format error")));
      var PolicyStr = JSON.stringify(Policy);
      if (!Policy.version)
        Policy.version = "2.0";
      var headers = params.Headers;
      headers["Content-Type"] = "application/json";
      headers["Content-MD5"] = util.binaryBase64(util.md5(PolicyStr));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketPolicy",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        action: "policy",
        body: PolicyStr,
        headers
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketPolicy(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketPolicy",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "policy",
        rawBody: true
      }, function(err, data) {
        if (err) {
          if (err.statusCode && err.statusCode === 403) {
            return callback(util.error(err, { ErrorStatus: "Access Denied" }));
          }
          if (err.statusCode && err.statusCode === 405) {
            return callback(util.error(err, { ErrorStatus: "Method Not Allowed" }));
          }
          if (err.statusCode && err.statusCode === 404) {
            return callback(util.error(err, { ErrorStatus: "Policy Not Found" }));
          }
          return callback(err);
        }
        var Policy = {};
        try {
          Policy = JSON.parse(data.body);
        } catch (e) {
        }
        callback(null, {
          Policy,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function deleteBucketPolicy(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteBucketPolicy",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "policy"
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode || err.statusCode,
          headers: data.headers
        });
      });
    }
    function putBucketTagging(params, callback) {
      var Tagging = params["Tagging"] || {};
      var Tags = Tagging.TagSet || Tagging.Tags || params["Tags"] || [];
      Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
      var xml = util.json2xml({ Tagging: { TagSet: { Tag: Tags } } });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketTagging",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "tagging",
        headers
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketTagging(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketTagging",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "tagging"
      }, function(err, data) {
        if (err) {
          if (err.statusCode === 404 && err.error && (err.error === "Not Found" || err.error.Code === "NoSuchTagSet")) {
            var result = {
              Tags: [],
              statusCode: err.statusCode
            };
            err.headers && (result.headers = err.headers);
            callback(null, result);
          } else {
            callback(err);
          }
          return;
        }
        var Tags = [];
        try {
          Tags = data.Tagging.TagSet.Tag || [];
        } catch (e) {
        }
        Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
        callback(null, {
          Tags,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function deleteBucketTagging(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteBucketTagging",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "tagging"
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putBucketLifecycle(params, callback) {
      var LifecycleConfiguration = params["LifecycleConfiguration"] || {};
      var Rules = LifecycleConfiguration.Rules || params.Rules || [];
      Rules = util.clone(Rules);
      var xml = util.json2xml({ LifecycleConfiguration: { Rule: Rules } });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketLifecycle",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "lifecycle",
        headers
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketLifecycle(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketLifecycle",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "lifecycle"
      }, function(err, data) {
        if (err) {
          if (err.statusCode === 404 && err.error && err.error.Code === "NoSuchLifecycleConfiguration") {
            var result = {
              Rules: [],
              statusCode: err.statusCode
            };
            err.headers && (result.headers = err.headers);
            callback(null, result);
          } else {
            callback(err);
          }
          return;
        }
        var Rules = [];
        try {
          Rules = data.LifecycleConfiguration.Rule || [];
        } catch (e) {
        }
        Rules = util.clone(util.isArray(Rules) ? Rules : [Rules]);
        callback(null, {
          Rules,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function deleteBucketLifecycle(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteBucketLifecycle",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "lifecycle"
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putBucketVersioning(params, callback) {
      if (!params["VersioningConfiguration"]) {
        callback(util.error(new Error("missing param VersioningConfiguration")));
        return;
      }
      var VersioningConfiguration = params["VersioningConfiguration"] || {};
      var xml = util.json2xml({ VersioningConfiguration });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketVersioning",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "versioning",
        headers
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketVersioning(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketVersioning",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "versioning"
      }, function(err, data) {
        if (!err) {
          !data.VersioningConfiguration && (data.VersioningConfiguration = {});
        }
        callback(err, data);
      });
    }
    function putBucketReplication(params, callback) {
      var ReplicationConfiguration = util.clone(params.ReplicationConfiguration);
      var xml = util.json2xml({ ReplicationConfiguration });
      xml = xml.replace(/<(\/?)Rules>/ig, "<$1Rule>");
      xml = xml.replace(/<(\/?)Tags>/ig, "<$1Tag>");
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketReplication",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "replication",
        headers
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketReplication(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketReplication",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "replication"
      }, function(err, data) {
        if (err) {
          if (err.statusCode === 404 && err.error && (err.error === "Not Found" || err.error.Code === "ReplicationConfigurationnotFoundError")) {
            var result = {
              ReplicationConfiguration: { Rules: [] },
              statusCode: err.statusCode
            };
            err.headers && (result.headers = err.headers);
            callback(null, result);
          } else {
            callback(err);
          }
          return;
        }
        !data.ReplicationConfiguration && (data.ReplicationConfiguration = {});
        if (data.ReplicationConfiguration.Rule) {
          data.ReplicationConfiguration.Rules = util.makeArray(data.ReplicationConfiguration.Rule);
          delete data.ReplicationConfiguration.Rule;
        }
        callback(err, data);
      });
    }
    function deleteBucketReplication(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteBucketReplication",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "replication"
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putBucketWebsite(params, callback) {
      if (!params["WebsiteConfiguration"]) {
        callback(util.error(new Error("missing param WebsiteConfiguration")));
        return;
      }
      var WebsiteConfiguration = util.clone(params["WebsiteConfiguration"] || {});
      var RoutingRules = WebsiteConfiguration["RoutingRules"] || WebsiteConfiguration["RoutingRule"] || [];
      RoutingRules = util.isArray(RoutingRules) ? RoutingRules : [RoutingRules];
      delete WebsiteConfiguration.RoutingRule;
      delete WebsiteConfiguration.RoutingRules;
      if (RoutingRules.length)
        WebsiteConfiguration.RoutingRules = { RoutingRule: RoutingRules };
      var xml = util.json2xml({ WebsiteConfiguration });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketWebsite",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "website",
        headers
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketWebsite(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketWebsite",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: params.Headers,
        action: "website"
      }, function(err, data) {
        if (err) {
          if (err.statusCode === 404 && err.error.Code === "NoSuchWebsiteConfiguration") {
            var result = {
              WebsiteConfiguration: {},
              statusCode: err.statusCode
            };
            err.headers && (result.headers = err.headers);
            callback(null, result);
          } else {
            callback(err);
          }
          return;
        }
        var WebsiteConfiguration = data.WebsiteConfiguration || {};
        if (WebsiteConfiguration["RoutingRules"]) {
          var RoutingRules = util.clone(WebsiteConfiguration["RoutingRules"].RoutingRule || []);
          RoutingRules = util.makeArray(RoutingRules);
          WebsiteConfiguration.RoutingRules = RoutingRules;
        }
        callback(null, {
          WebsiteConfiguration,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function deleteBucketWebsite(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteBucketWebsite",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "website"
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putBucketReferer(params, callback) {
      if (!params["RefererConfiguration"]) {
        callback(util.error(new Error("missing param RefererConfiguration")));
        return;
      }
      var RefererConfiguration = util.clone(params["RefererConfiguration"] || {});
      var DomainList = RefererConfiguration["DomainList"] || {};
      var Domains = DomainList["Domains"] || DomainList["Domain"] || [];
      Domains = util.isArray(Domains) ? Domains : [Domains];
      if (Domains.length)
        RefererConfiguration.DomainList = { Domain: Domains };
      var xml = util.json2xml({ RefererConfiguration });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketReferer",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "referer",
        headers
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketReferer(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketReferer",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: params.Headers,
        action: "referer"
      }, function(err, data) {
        if (err) {
          if (err.statusCode === 404 && err.error.Code === "NoSuchRefererConfiguration") {
            var result = {
              WebsiteConfiguration: {},
              statusCode: err.statusCode
            };
            err.headers && (result.headers = err.headers);
            callback(null, result);
          } else {
            callback(err);
          }
          return;
        }
        var RefererConfiguration = data.RefererConfiguration || {};
        if (RefererConfiguration["DomainList"]) {
          var Domains = util.makeArray(RefererConfiguration["DomainList"].Domain || []);
          RefererConfiguration.DomainList = { Domains };
        }
        callback(null, {
          RefererConfiguration,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putBucketDomain(params, callback) {
      var DomainConfiguration = params["DomainConfiguration"] || {};
      var DomainRule = DomainConfiguration.DomainRule || params.DomainRule || [];
      DomainRule = util.clone(DomainRule);
      var xml = util.json2xml({ DomainConfiguration: { DomainRule } });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketDomain",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "domain",
        headers
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketDomain(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketDomain",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "domain"
      }, function(err, data) {
        if (err)
          return callback(err);
        var DomainRule = [];
        try {
          DomainRule = data.DomainConfiguration.DomainRule || [];
        } catch (e) {
        }
        DomainRule = util.clone(util.isArray(DomainRule) ? DomainRule : [DomainRule]);
        callback(null, {
          DomainRule,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function deleteBucketDomain(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteBucketDomain",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "domain"
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putBucketOrigin(params, callback) {
      var OriginConfiguration = params["OriginConfiguration"] || {};
      var OriginRule = OriginConfiguration.OriginRule || params.OriginRule || [];
      OriginRule = util.clone(OriginRule);
      var xml = util.json2xml({ OriginConfiguration: { OriginRule } });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketOrigin",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "origin",
        headers
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketOrigin(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketOrigin",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "origin"
      }, function(err, data) {
        if (err)
          return callback(err);
        var OriginRule = [];
        try {
          OriginRule = data.OriginConfiguration.OriginRule || [];
        } catch (e) {
        }
        OriginRule = util.clone(util.isArray(OriginRule) ? OriginRule : [OriginRule]);
        callback(null, {
          OriginRule,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function deleteBucketOrigin(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteBucketOrigin",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "origin"
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putBucketLogging(params, callback) {
      var xml = util.json2xml({
        BucketLoggingStatus: params["BucketLoggingStatus"] || ""
      });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketLogging",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "logging",
        headers
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketLogging(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketLogging",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "logging"
      }, function(err, data) {
        if (err)
          return callback(err);
        callback(null, {
          BucketLoggingStatus: data.BucketLoggingStatus,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putBucketInventory(params, callback) {
      var InventoryConfiguration = util.clone(params["InventoryConfiguration"]);
      if (InventoryConfiguration.OptionalFields) {
        var Field = InventoryConfiguration.OptionalFields || [];
        InventoryConfiguration.OptionalFields = {
          Field
        };
      }
      if (InventoryConfiguration.Destination && InventoryConfiguration.Destination.COSBucketDestination && InventoryConfiguration.Destination.COSBucketDestination.Encryption) {
        var Encryption = InventoryConfiguration.Destination.COSBucketDestination.Encryption;
        if (Object.keys(Encryption).indexOf("SSECOS") > -1) {
          Encryption["SSE-COS"] = Encryption["SSECOS"];
          delete Encryption["SSECOS"];
        }
      }
      var xml = util.json2xml({
        InventoryConfiguration
      });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketInventory",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "inventory",
        qs: {
          id: params["Id"]
        },
        headers
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketInventory(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketInventory",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "inventory",
        qs: {
          id: params["Id"]
        }
      }, function(err, data) {
        if (err)
          return callback(err);
        var InventoryConfiguration = data["InventoryConfiguration"];
        if (InventoryConfiguration && InventoryConfiguration.OptionalFields && InventoryConfiguration.OptionalFields.Field) {
          var Field = InventoryConfiguration.OptionalFields.Field;
          if (!util.isArray(Field)) {
            Field = [Field];
          }
          InventoryConfiguration.OptionalFields = Field;
        }
        if (InventoryConfiguration.Destination && InventoryConfiguration.Destination.COSBucketDestination && InventoryConfiguration.Destination.COSBucketDestination.Encryption) {
          var Encryption = InventoryConfiguration.Destination.COSBucketDestination.Encryption;
          if (Object.keys(Encryption).indexOf("SSE-COS") > -1) {
            Encryption["SSECOS"] = Encryption["SSE-COS"];
            delete Encryption["SSE-COS"];
          }
        }
        callback(null, {
          InventoryConfiguration,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function listBucketInventory(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:ListBucketInventory",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "inventory",
        qs: {
          "continuation-token": params["ContinuationToken"]
        }
      }, function(err, data) {
        if (err)
          return callback(err);
        var ListInventoryConfigurationResult = data["ListInventoryConfigurationResult"];
        var InventoryConfigurations = ListInventoryConfigurationResult.InventoryConfiguration || [];
        InventoryConfigurations = util.isArray(InventoryConfigurations) ? InventoryConfigurations : [InventoryConfigurations];
        delete ListInventoryConfigurationResult["InventoryConfiguration"];
        util.each(InventoryConfigurations, function(InventoryConfiguration) {
          if (InventoryConfiguration && InventoryConfiguration.OptionalFields && InventoryConfiguration.OptionalFields.Field) {
            var Field = InventoryConfiguration.OptionalFields.Field;
            if (!util.isArray(Field)) {
              Field = [Field];
            }
            InventoryConfiguration.OptionalFields = Field;
          }
          if (InventoryConfiguration.Destination && InventoryConfiguration.Destination.COSBucketDestination && InventoryConfiguration.Destination.COSBucketDestination.Encryption) {
            var Encryption = InventoryConfiguration.Destination.COSBucketDestination.Encryption;
            if (Object.keys(Encryption).indexOf("SSE-COS") > -1) {
              Encryption["SSECOS"] = Encryption["SSE-COS"];
              delete Encryption["SSE-COS"];
            }
          }
        });
        ListInventoryConfigurationResult.InventoryConfigurations = InventoryConfigurations;
        util.extend(ListInventoryConfigurationResult, {
          statusCode: data.statusCode,
          headers: data.headers
        });
        callback(null, ListInventoryConfigurationResult);
      });
    }
    function deleteBucketInventory(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteBucketInventory",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "inventory",
        qs: {
          id: params["Id"]
        }
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putBucketAccelerate(params, callback) {
      if (!params["AccelerateConfiguration"]) {
        callback(util.error(new Error("missing param AccelerateConfiguration")));
        return;
      }
      var configuration = { AccelerateConfiguration: params.AccelerateConfiguration || {} };
      var xml = util.json2xml(configuration);
      var headers = {};
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketAccelerate",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "accelerate",
        headers
      }, function(err, data) {
        if (err)
          return callback(err);
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketAccelerate(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketAccelerate",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        action: "accelerate"
      }, function(err, data) {
        if (!err) {
          !data.AccelerateConfiguration && (data.AccelerateConfiguration = {});
        }
        callback(err, data);
      });
    }
    function putBucketEncryption(params, callback) {
      var conf = params.ServerSideEncryptionConfiguration || {};
      var Rules = conf.Rule || conf.Rules || [];
      var xml = util.json2xml({ ServerSideEncryptionConfiguration: { Rule: Rules } });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutBucketEncryption",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "encryption",
        headers
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getBucketEncryption(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetBucketEncryption",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "encryption"
      }, function(err, data) {
        if (err) {
          if (err.statusCode === 404 && err.code === "NoSuchEncryptionConfiguration") {
            var result = {
              EncryptionConfiguration: { Rules: [] },
              statusCode: err.statusCode
            };
            err.headers && (result.headers = err.headers);
            callback(null, result);
          } else {
            callback(err);
          }
          return;
        }
        var Rules = util.makeArray(data.EncryptionConfiguration && data.EncryptionConfiguration.Rule || []);
        data.EncryptionConfiguration = { Rules };
        callback(err, data);
      });
    }
    function deleteBucketEncryption(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteBucketReplication",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "encryption"
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function headObject(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:HeadObject",
        method: "HEAD",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        VersionId: params.VersionId,
        headers: params.Headers
      }, function(err, data) {
        if (err) {
          var statusCode = err.statusCode;
          if (params.Headers["If-Modified-Since"] && statusCode && statusCode === 304) {
            return callback(null, {
              NotModified: true,
              statusCode
            });
          }
          return callback(err);
        }
        data.ETag = util.attr(data.headers, "etag", "");
        callback(null, data);
      });
    }
    function listObjectVersions(params, callback) {
      var reqParams = {};
      reqParams["prefix"] = params["Prefix"] || "";
      reqParams["delimiter"] = params["Delimiter"];
      reqParams["key-marker"] = params["KeyMarker"];
      reqParams["version-id-marker"] = params["VersionIdMarker"];
      reqParams["max-keys"] = params["MaxKeys"];
      reqParams["encoding-type"] = params["EncodingType"];
      submitRequest.call(this, {
        Action: "name/cos:GetBucketObjectVersions",
        ResourceKey: reqParams["prefix"],
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        qs: reqParams,
        action: "versions"
      }, function(err, data) {
        if (err)
          return callback(err);
        var ListVersionsResult = data.ListVersionsResult || {};
        var DeleteMarkers = ListVersionsResult.DeleteMarker || [];
        DeleteMarkers = util.isArray(DeleteMarkers) ? DeleteMarkers : [DeleteMarkers];
        var Versions = ListVersionsResult.Version || [];
        Versions = util.isArray(Versions) ? Versions : [Versions];
        var result = util.clone(ListVersionsResult);
        delete result.DeleteMarker;
        delete result.Version;
        util.extend(result, {
          DeleteMarkers,
          Versions,
          statusCode: data.statusCode,
          headers: data.headers
        });
        callback(null, result);
      });
    }
    function getObject(params, callback) {
      var reqParams = params.Query || {};
      var reqParamsStr = params.QueryString || "";
      var onProgress = util.throttleOnProgress.call(this, 0, params.onProgress);
      reqParams["response-content-type"] = params["ResponseContentType"];
      reqParams["response-content-language"] = params["ResponseContentLanguage"];
      reqParams["response-expires"] = params["ResponseExpires"];
      reqParams["response-cache-control"] = params["ResponseCacheControl"];
      reqParams["response-content-disposition"] = params["ResponseContentDisposition"];
      reqParams["response-content-encoding"] = params["ResponseContentEncoding"];
      submitRequest.call(this, {
        Action: "name/cos:GetObject",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        VersionId: params.VersionId,
        DataType: params.DataType,
        headers: params.Headers,
        qs: reqParams,
        qsStr: reqParamsStr,
        rawBody: true,
        onDownloadProgress: onProgress
      }, function(err, data) {
        onProgress(null, true);
        if (err) {
          var statusCode = err.statusCode;
          if (params.Headers["If-Modified-Since"] && statusCode && statusCode === 304) {
            return callback(null, {
              NotModified: true
            });
          }
          return callback(err);
        }
        callback(null, {
          Body: data.body,
          ETag: util.attr(data.headers, "etag", ""),
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putObject(params, callback) {
      var self2 = this;
      var FileSize = params.ContentLength;
      var onProgress = util.throttleOnProgress.call(self2, FileSize, params.onProgress);
      var headers = params.Headers;
      if (!headers["Cache-Control"] && !headers["cache-control"])
        headers["Cache-Control"] = "";
      if (!headers["Content-Type"] && !headers["content-type"])
        headers["Content-Type"] = params.Body && params.Body.type || "";
      var needCalcMd5 = params.UploadAddMetaMd5 || self2.options.UploadAddMetaMd5 || self2.options.UploadCheckContentMd5;
      util.getBodyMd5(needCalcMd5, params.Body, function(md5) {
        if (md5) {
          if (self2.options.UploadCheckContentMd5)
            headers["Content-MD5"] = util.binaryBase64(md5);
          if (params.UploadAddMetaMd5 || self2.options.UploadAddMetaMd5)
            headers["x-cos-meta-md5"] = md5;
        }
        if (params.ContentLength !== void 0)
          headers["Content-Length"] = params.ContentLength;
        onProgress(null, true);
        submitRequest.call(self2, {
          Action: "name/cos:PutObject",
          TaskId: params.TaskId,
          method: "PUT",
          Bucket: params.Bucket,
          Region: params.Region,
          Key: params.Key,
          headers: params.Headers,
          qs: params.Query,
          body: params.Body,
          onProgress
        }, function(err, data) {
          if (err) {
            onProgress(null, true);
            return callback(err);
          }
          onProgress({ loaded: FileSize, total: FileSize }, true);
          var url = getUrl({
            ForcePathStyle: self2.options.ForcePathStyle,
            protocol: self2.options.Protocol,
            domain: self2.options.Domain,
            bucket: params.Bucket,
            region: !self2.options.UseAccelerate ? params.Region : "accelerate",
            object: params.Key
          });
          url = url.substr(url.indexOf("://") + 3);
          data.Location = url;
          data.ETag = util.attr(data.headers, "etag", "");
          callback(null, data);
        });
      }, params.onHashProgress);
    }
    function deleteObject(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteObject",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: params.Headers,
        VersionId: params.VersionId,
        action: params.Recursive ? "recursive" : ""
      }, function(err, data) {
        if (err) {
          var statusCode = err.statusCode;
          if (statusCode && statusCode === 404) {
            return callback(null, { BucketNotFound: true, statusCode });
          } else {
            return callback(err);
          }
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getObjectAcl(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetObjectACL",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: params.Headers,
        action: "acl"
      }, function(err, data) {
        if (err)
          return callback(err);
        var AccessControlPolicy = data.AccessControlPolicy || {};
        var Owner = AccessControlPolicy.Owner || {};
        var Grant = AccessControlPolicy.AccessControlList && AccessControlPolicy.AccessControlList.Grant || [];
        Grant = util.isArray(Grant) ? Grant : [Grant];
        var result = decodeAcl(AccessControlPolicy);
        delete result.GrantWrite;
        if (data.headers && data.headers["x-cos-acl"]) {
          result.ACL = data.headers["x-cos-acl"];
        }
        result = util.extend(result, {
          Owner,
          Grants: Grant,
          statusCode: data.statusCode,
          headers: data.headers
        });
        callback(null, result);
      });
    }
    function putObjectAcl(params, callback) {
      var headers = params.Headers;
      var xml = "";
      if (params["AccessControlPolicy"]) {
        var AccessControlPolicy = util.clone(params["AccessControlPolicy"] || {});
        var Grants = AccessControlPolicy.Grants || AccessControlPolicy.Grant;
        Grants = util.isArray(Grants) ? Grants : [Grants];
        delete AccessControlPolicy.Grant;
        delete AccessControlPolicy.Grants;
        AccessControlPolicy.AccessControlList = { Grant: Grants };
        xml = util.json2xml({ AccessControlPolicy });
        headers["Content-Type"] = "application/xml";
        headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      }
      util.each(headers, function(val, key) {
        if (key.indexOf("x-cos-grant-") === 0) {
          headers[key] = uniqGrant(headers[key]);
        }
      });
      submitRequest.call(this, {
        Action: "name/cos:PutObjectACL",
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        action: "acl",
        headers,
        body: xml
      }, function(err, data) {
        if (err)
          return callback(err);
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function optionsObject(params, callback) {
      var headers = params.Headers;
      headers["Origin"] = params["Origin"];
      headers["Access-Control-Request-Method"] = params["AccessControlRequestMethod"];
      headers["Access-Control-Request-Headers"] = params["AccessControlRequestHeaders"];
      submitRequest.call(this, {
        Action: "name/cos:OptionsObject",
        method: "OPTIONS",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers
      }, function(err, data) {
        if (err) {
          if (err.statusCode && err.statusCode === 403) {
            return callback(null, {
              OptionsForbidden: true,
              statusCode: err.statusCode
            });
          }
          return callback(err);
        }
        var headers2 = data.headers || {};
        callback(null, {
          AccessControlAllowOrigin: headers2["access-control-allow-origin"],
          AccessControlAllowMethods: headers2["access-control-allow-methods"],
          AccessControlAllowHeaders: headers2["access-control-allow-headers"],
          AccessControlExposeHeaders: headers2["access-control-expose-headers"],
          AccessControlMaxAge: headers2["access-control-max-age"],
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function putObjectCopy(params, callback) {
      var self2 = this;
      var headers = params.Headers;
      if (!headers["Cache-Control"] && !headers["cache-control"])
        headers["Cache-Control"] = "";
      var CopySource = params.CopySource || "";
      var m = util.getSourceParams.call(this, CopySource);
      if (!m) {
        callback(util.error(new Error("CopySource format error")));
        return;
      }
      var SourceBucket = m[1];
      var SourceRegion = m[3];
      var SourceKey = decodeURIComponent(m[4]);
      submitRequest.call(this, {
        Scope: [{
          action: "name/cos:GetObject",
          bucket: SourceBucket,
          region: SourceRegion,
          prefix: SourceKey
        }, {
          action: "name/cos:PutObject",
          bucket: params.Bucket,
          region: params.Region,
          prefix: params.Key
        }],
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        VersionId: params.VersionId,
        headers: params.Headers
      }, function(err, data) {
        if (err)
          return callback(err);
        var result = util.clone(data.CopyObjectResult || {});
        var url = getUrl({
          ForcePathStyle: self2.options.ForcePathStyle,
          protocol: self2.options.Protocol,
          domain: self2.options.Domain,
          bucket: params.Bucket,
          region: params.Region,
          object: params.Key,
          isLocation: true
        });
        util.extend(result, {
          Location: url,
          statusCode: data.statusCode,
          headers: data.headers
        });
        callback(null, result);
      });
    }
    function uploadPartCopy(params, callback) {
      var CopySource = params.CopySource || "";
      var m = util.getSourceParams.call(this, CopySource);
      if (!m) {
        callback(util.error(new Error("CopySource format error")));
        return;
      }
      var SourceBucket = m[1];
      var SourceRegion = m[3];
      var SourceKey = decodeURIComponent(m[4]);
      submitRequest.call(this, {
        Scope: [{
          action: "name/cos:GetObject",
          bucket: SourceBucket,
          region: SourceRegion,
          prefix: SourceKey
        }, {
          action: "name/cos:PutObject",
          bucket: params.Bucket,
          region: params.Region,
          prefix: params.Key
        }],
        method: "PUT",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        VersionId: params.VersionId,
        qs: {
          partNumber: params["PartNumber"],
          uploadId: params["UploadId"]
        },
        headers: params.Headers
      }, function(err, data) {
        if (err)
          return callback(err);
        var result = util.clone(data.CopyPartResult || {});
        util.extend(result, {
          statusCode: data.statusCode,
          headers: data.headers
        });
        callback(null, result);
      });
    }
    function deleteMultipleObject(params, callback) {
      var Objects = params.Objects || [];
      var Quiet = params.Quiet;
      Objects = util.isArray(Objects) ? Objects : [Objects];
      var xml = util.json2xml({ Delete: { Object: Objects, Quiet: Quiet || false } });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      var Scope = util.map(Objects, function(v) {
        return {
          action: "name/cos:DeleteObject",
          bucket: params.Bucket,
          region: params.Region,
          prefix: v.Key
        };
      });
      submitRequest.call(this, {
        Scope,
        method: "POST",
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: "delete",
        headers
      }, function(err, data) {
        if (err)
          return callback(err);
        var DeleteResult = data.DeleteResult || {};
        var Deleted = DeleteResult.Deleted || [];
        var Errors = DeleteResult.Error || [];
        Deleted = util.isArray(Deleted) ? Deleted : [Deleted];
        Errors = util.isArray(Errors) ? Errors : [Errors];
        var result = util.clone(DeleteResult);
        util.extend(result, {
          Error: Errors,
          Deleted,
          statusCode: data.statusCode,
          headers: data.headers
        });
        callback(null, result);
      });
    }
    function restoreObject(params, callback) {
      var headers = params.Headers;
      if (!params["RestoreRequest"]) {
        callback(util.error(new Error("missing param RestoreRequest")));
        return;
      }
      var RestoreRequest = params.RestoreRequest || {};
      var xml = util.json2xml({ RestoreRequest });
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:RestoreObject",
        method: "POST",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        VersionId: params.VersionId,
        body: xml,
        action: "restore",
        headers
      }, callback);
    }
    function putObjectTagging(params, callback) {
      var Tagging = params["Tagging"] || {};
      var Tags = Tagging.TagSet || Tagging.Tags || params["Tags"] || [];
      Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
      var xml = util.json2xml({ Tagging: { TagSet: { Tag: Tags } } });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:PutObjectTagging",
        method: "PUT",
        Bucket: params.Bucket,
        Key: params.Key,
        Region: params.Region,
        body: xml,
        action: "tagging",
        headers,
        VersionId: params.VersionId
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function getObjectTagging(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:GetObjectTagging",
        method: "GET",
        Key: params.Key,
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: "tagging",
        VersionId: params.VersionId
      }, function(err, data) {
        if (err) {
          if (err.statusCode === 404 && err.error && (err.error === "Not Found" || err.error.Code === "NoSuchTagSet")) {
            var result = {
              Tags: [],
              statusCode: err.statusCode
            };
            err.headers && (result.headers = err.headers);
            callback(null, result);
          } else {
            callback(err);
          }
          return;
        }
        var Tags = [];
        try {
          Tags = data.Tagging.TagSet.Tag || [];
        } catch (e) {
        }
        Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
        callback(null, {
          Tags,
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function deleteObjectTagging(params, callback) {
      submitRequest.call(this, {
        Action: "name/cos:DeleteObjectTagging",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: params.Headers,
        action: "tagging",
        VersionId: params.VersionId
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function selectObjectContent(params, callback) {
      var SelectType = params["SelectType"];
      if (!SelectType)
        return callback(util.error(new Error("missing param SelectType")));
      var SelectRequest = params["SelectRequest"] || {};
      var xml = util.json2xml({ SelectRequest });
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:GetObject",
        method: "POST",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: params.Headers,
        action: "select",
        qs: {
          "select-type": params["SelectType"]
        },
        VersionId: params.VersionId,
        body: xml,
        DataType: "arraybuffer",
        rawBody: true
      }, function(err, data) {
        if (err && err.statusCode === 204) {
          return callback(null, { statusCode: err.statusCode });
        } else if (err) {
          return callback(err);
        }
        var result = util.parseSelectPayload(data.body);
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers,
          Body: result.body,
          Payload: result.payload
        });
      });
    }
    function multipartInit(params, callback) {
      var self2 = this;
      var headers = params.Headers;
      if (!headers["Cache-Control"] && !headers["cache-control"])
        headers["Cache-Control"] = "";
      if (!headers["Content-Type"] && !headers["content-type"])
        headers["Content-Type"] = params.Body && params.Body.type || "";
      util.getBodyMd5(params.Body && (params.UploadAddMetaMd5 || self2.options.UploadAddMetaMd5), params.Body, function(md5) {
        if (md5)
          params.Headers["x-cos-meta-md5"] = md5;
        submitRequest.call(self2, {
          Action: "name/cos:InitiateMultipartUpload",
          method: "POST",
          Bucket: params.Bucket,
          Region: params.Region,
          Key: params.Key,
          action: "uploads",
          headers: params.Headers,
          qs: params.Query
        }, function(err, data) {
          if (err)
            return callback(err);
          data = util.clone(data || {});
          if (data && data.InitiateMultipartUploadResult) {
            return callback(null, util.extend(data.InitiateMultipartUploadResult, {
              statusCode: data.statusCode,
              headers: data.headers
            }));
          }
          callback(null, data);
        });
      }, params.onHashProgress);
    }
    function multipartUpload(params, callback) {
      var self2 = this;
      util.getFileSize("multipartUpload", params, function() {
        util.getBodyMd5(self2.options.UploadCheckContentMd5, params.Body, function(md5) {
          if (md5)
            params.Headers["Content-MD5"] = util.binaryBase64(md5);
          submitRequest.call(self2, {
            Action: "name/cos:UploadPart",
            TaskId: params.TaskId,
            method: "PUT",
            Bucket: params.Bucket,
            Region: params.Region,
            Key: params.Key,
            qs: {
              partNumber: params["PartNumber"],
              uploadId: params["UploadId"]
            },
            headers: params.Headers,
            onProgress: params.onProgress,
            body: params.Body || null
          }, function(err, data) {
            if (err)
              return callback(err);
            callback(null, {
              ETag: util.attr(data.headers, "etag", ""),
              statusCode: data.statusCode,
              headers: data.headers
            });
          });
        });
      });
    }
    function multipartComplete(params, callback) {
      var self2 = this;
      var UploadId = params.UploadId;
      var Parts = params["Parts"];
      for (var i = 0, len = Parts.length; i < len; i++) {
        if (Parts[i]["ETag"] && Parts[i]["ETag"].indexOf('"') === 0) {
          continue;
        }
        Parts[i]["ETag"] = '"' + Parts[i]["ETag"] + '"';
      }
      var xml = util.json2xml({ CompleteMultipartUpload: { Part: Parts } });
      xml = xml.replace(/\n\s*/g, "");
      var headers = params.Headers;
      headers["Content-Type"] = "application/xml";
      headers["Content-MD5"] = util.binaryBase64(util.md5(xml));
      submitRequest.call(this, {
        Action: "name/cos:CompleteMultipartUpload",
        method: "POST",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        qs: {
          uploadId: UploadId
        },
        body: xml,
        headers
      }, function(err, data) {
        if (err)
          return callback(err);
        var url = getUrl({
          ForcePathStyle: self2.options.ForcePathStyle,
          protocol: self2.options.Protocol,
          domain: self2.options.Domain,
          bucket: params.Bucket,
          region: params.Region,
          object: params.Key,
          isLocation: true
        });
        var res = data.CompleteMultipartUploadResult || {};
        if (res.ProcessResults) {
          if (res && res.ProcessResults) {
            res.UploadResult = {
              OriginalInfo: {
                Key: res.Key,
                Location: url,
                ETag: res.ETag,
                ImageInfo: res.ImageInfo
              },
              ProcessResults: res.ProcessResults
            };
            delete res.ImageInfo;
            delete res.ProcessResults;
          }
        }
        var result = util.extend(res, {
          Location: url,
          statusCode: data.statusCode,
          headers: data.headers
        });
        callback(null, result);
      });
    }
    function multipartList(params, callback) {
      var reqParams = {};
      reqParams["delimiter"] = params["Delimiter"];
      reqParams["encoding-type"] = params["EncodingType"];
      reqParams["prefix"] = params["Prefix"] || "";
      reqParams["max-uploads"] = params["MaxUploads"];
      reqParams["key-marker"] = params["KeyMarker"];
      reqParams["upload-id-marker"] = params["UploadIdMarker"];
      reqParams = util.clearKey(reqParams);
      submitRequest.call(this, {
        Action: "name/cos:ListMultipartUploads",
        ResourceKey: reqParams["prefix"],
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        qs: reqParams,
        action: "uploads"
      }, function(err, data) {
        if (err)
          return callback(err);
        if (data && data.ListMultipartUploadsResult) {
          var Upload = data.ListMultipartUploadsResult.Upload || [];
          Upload = util.isArray(Upload) ? Upload : [Upload];
          data.ListMultipartUploadsResult.Upload = Upload;
        }
        var result = util.clone(data.ListMultipartUploadsResult || {});
        util.extend(result, {
          statusCode: data.statusCode,
          headers: data.headers
        });
        callback(null, result);
      });
    }
    function multipartListPart(params, callback) {
      var reqParams = {};
      reqParams["uploadId"] = params["UploadId"];
      reqParams["encoding-type"] = params["EncodingType"];
      reqParams["max-parts"] = params["MaxParts"];
      reqParams["part-number-marker"] = params["PartNumberMarker"];
      submitRequest.call(this, {
        Action: "name/cos:ListParts",
        method: "GET",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: params.Headers,
        qs: reqParams
      }, function(err, data) {
        if (err)
          return callback(err);
        var ListPartsResult = data.ListPartsResult || {};
        var Part = ListPartsResult.Part || [];
        Part = util.isArray(Part) ? Part : [Part];
        ListPartsResult.Part = Part;
        var result = util.clone(ListPartsResult);
        util.extend(result, {
          statusCode: data.statusCode,
          headers: data.headers
        });
        callback(null, result);
      });
    }
    function multipartAbort(params, callback) {
      var reqParams = {};
      reqParams["uploadId"] = params["UploadId"];
      submitRequest.call(this, {
        Action: "name/cos:AbortMultipartUpload",
        method: "DELETE",
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: params.Headers,
        qs: reqParams
      }, function(err, data) {
        if (err)
          return callback(err);
        callback(null, {
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    }
    function request(params, callback) {
      submitRequest.call(this, {
        method: params.Method,
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        action: params.Action,
        headers: params.Headers,
        qs: params.Query,
        body: params.Body,
        Url: params.Url,
        rawBody: params.RawBody,
        DataType: params.DataType
      }, function(err, data) {
        if (err)
          return callback(err);
        if (data && data.body) {
          data.Body = data.body;
          delete data.body;
        }
        callback(err, data);
      });
    }
    function appendObject(params, callback) {
      var headers = params.Headers;
      if (!headers["Cache-Control"] && !headers["cache-control"])
        headers["Cache-Control"] = "";
      if (!headers["Content-Type"] && !headers["content-type"])
        headers["Content-Type"] = params.Body && params.Body.type || "";
      submitRequest.call(this, {
        Action: "name/cos:AppendObject",
        method: "POST",
        Bucket: params.Bucket,
        Region: params.Region,
        action: "append",
        Key: params.Key,
        body: params.Body,
        qs: {
          position: params.Position
        },
        headers: params.Headers
      }, function(err, data) {
        if (err)
          return callback(err);
        callback(null, data);
      });
    }
    function getAuth(params) {
      var self2 = this;
      return util.getAuth({
        SecretId: params.SecretId || this.options.SecretId || "",
        SecretKey: params.SecretKey || this.options.SecretKey || "",
        Bucket: params.Bucket,
        Region: params.Region,
        Method: params.Method,
        Key: params.Key,
        Query: params.Query,
        Headers: params.Headers,
        Expires: params.Expires,
        UseRawKey: self2.options.UseRawKey,
        SystemClockOffset: self2.options.SystemClockOffset
      });
    }
    function getObjectUrl(params, callback) {
      var self2 = this;
      var useAccelerate = params.UseAccelerate === void 0 ? self2.options.UseAccelerate : params.UseAccelerate;
      var url = getUrl({
        ForcePathStyle: self2.options.ForcePathStyle,
        protocol: params.Protocol || self2.options.Protocol,
        domain: params.Domain || self2.options.Domain,
        bucket: params.Bucket,
        region: useAccelerate ? "accelerate" : params.Region,
        object: params.Key
      });
      var queryParamsStr = "";
      if (params.Query) {
        queryParamsStr += util.obj2str(params.Query);
      }
      if (params.QueryString) {
        queryParamsStr += (queryParamsStr ? "&" : "") + params.QueryString;
      }
      var syncUrl = url;
      if (params.Sign !== void 0 && !params.Sign) {
        queryParamsStr && (syncUrl += "?" + queryParamsStr);
        callback(null, { Url: syncUrl });
        return syncUrl;
      }
      var SignHost = getSignHost.call(this, { Bucket: params.Bucket, Region: params.Region, UseAccelerate: params.UseAccelerate, Url: url });
      var AuthData = getAuthorizationAsync.call(this, {
        Action: (params.Method || "").toUpperCase() === "PUT" ? "name/cos:PutObject" : "name/cos:GetObject",
        Bucket: params.Bucket || "",
        Region: params.Region || "",
        Method: params.Method || "get",
        Key: params.Key,
        Expires: params.Expires,
        Headers: params.Headers,
        Query: params.Query,
        SignHost,
        ForceSignHost: params.ForceSignHost === false ? false : self2.options.ForceSignHost
      }, function(err, AuthData2) {
        if (!callback)
          return;
        if (err) {
          callback(err);
          return;
        }
        var replaceUrlParamList = function(url2) {
          var urlParams = url2.match(/q-url-param-list.*?(?=&)/g)[0];
          var encodedParams = "q-url-param-list=" + encodeURIComponent(urlParams.replace(/q-url-param-list=/, "")).toLowerCase();
          var reg = new RegExp(urlParams, "g");
          var replacedUrl = url2.replace(reg, encodedParams);
          return replacedUrl;
        };
        var signUrl = url;
        signUrl += "?" + (AuthData2.Authorization.indexOf("q-signature") > -1 ? replaceUrlParamList(AuthData2.Authorization) : "sign=" + encodeURIComponent(AuthData2.Authorization));
        AuthData2.SecurityToken && (signUrl += "&x-cos-security-token=" + AuthData2.SecurityToken);
        AuthData2.ClientIP && (signUrl += "&clientIP=" + AuthData2.ClientIP);
        AuthData2.ClientUA && (signUrl += "&clientUA=" + AuthData2.ClientUA);
        AuthData2.Token && (signUrl += "&token=" + AuthData2.Token);
        queryParamsStr && (signUrl += "&" + queryParamsStr);
        setTimeout(function() {
          callback(null, { Url: signUrl });
        });
      });
      if (AuthData) {
        syncUrl += "?" + AuthData.Authorization + (AuthData.SecurityToken ? "&x-cos-security-token=" + AuthData.SecurityToken : "");
        queryParamsStr && (syncUrl += "&" + queryParamsStr);
      } else {
        queryParamsStr && (syncUrl += "?" + queryParamsStr);
      }
      return syncUrl;
    }
    function decodeAcl(AccessControlPolicy) {
      var result = {
        GrantFullControl: [],
        GrantWrite: [],
        GrantRead: [],
        GrantReadAcp: [],
        GrantWriteAcp: [],
        ACL: ""
      };
      var GrantMap = {
        "FULL_CONTROL": "GrantFullControl",
        "WRITE": "GrantWrite",
        "READ": "GrantRead",
        "READ_ACP": "GrantReadAcp",
        "WRITE_ACP": "GrantWriteAcp"
      };
      var AccessControlList = AccessControlPolicy && AccessControlPolicy.AccessControlList || {};
      var Grant = AccessControlList.Grant;
      if (Grant) {
        Grant = util.isArray(Grant) ? Grant : [Grant];
      }
      var PublicAcl = { READ: 0, WRITE: 0, FULL_CONTROL: 0 };
      Grant && Grant.length && util.each(Grant, function(item) {
        if (item.Grantee.ID === "qcs::cam::anyone:anyone" || item.Grantee.URI === "http://cam.qcloud.com/groups/global/AllUsers") {
          PublicAcl[item.Permission] = 1;
        } else if (item.Grantee.ID !== AccessControlPolicy.Owner.ID) {
          result[GrantMap[item.Permission]].push('id="' + item.Grantee.ID + '"');
        }
      });
      if (PublicAcl.FULL_CONTROL || PublicAcl.WRITE && PublicAcl.READ) {
        result.ACL = "public-read-write";
      } else if (PublicAcl.READ) {
        result.ACL = "public-read";
      } else {
        result.ACL = "private";
      }
      util.each(GrantMap, function(item) {
        result[item] = uniqGrant(result[item].join(","));
      });
      return result;
    }
    function uniqGrant(str) {
      var arr = str.split(",");
      var exist = {};
      var i, item;
      for (i = 0; i < arr.length; ) {
        item = arr[i].trim();
        if (exist[item]) {
          arr.splice(i, 1);
        } else {
          exist[item] = true;
          arr[i] = item;
          i++;
        }
      }
      return arr.join(",");
    }
    function getUrl(params) {
      var region = params.region || "";
      var longBucket = params.bucket || "";
      var shortBucket = longBucket.substr(0, longBucket.lastIndexOf("-"));
      var appId = longBucket.substr(longBucket.lastIndexOf("-") + 1);
      var domain = params.domain;
      var object = params.object;
      if (typeof domain === "function") {
        domain = domain({ Bucket: longBucket, Region: region });
      }
      var protocol = params.protocol || (util.isBrowser && location.protocol === "http:" ? "http:" : "https:");
      if (!domain) {
        if (["cn-south", "cn-south-2", "cn-north", "cn-east", "cn-southwest", "sg"].indexOf(region) > -1) {
          domain = "{Region}.myqcloud.com";
        } else {
          domain = "cos.{Region}.myqcloud.com";
        }
        if (!params.ForcePathStyle) {
          domain = "{Bucket}." + domain;
        }
      }
      domain = domain.replace(/\{\{AppId\}\}/ig, appId).replace(/\{\{Bucket\}\}/ig, shortBucket).replace(/\{\{Region\}\}/ig, region).replace(/\{\{.*?\}\}/ig, "");
      domain = domain.replace(/\{AppId\}/ig, appId).replace(/\{BucketName\}/ig, shortBucket).replace(/\{Bucket\}/ig, longBucket).replace(/\{Region\}/ig, region).replace(/\{.*?\}/ig, "");
      if (!/^[a-zA-Z]+:\/\//.test(domain)) {
        domain = protocol + "//" + domain;
      }
      if (domain.slice(-1) === "/") {
        domain = domain.slice(0, -1);
      }
      var url = domain;
      if (params.ForcePathStyle) {
        url += "/" + longBucket;
      }
      url += "/";
      if (object) {
        url += util.camSafeUrlEncode(object).replace(/%2F/g, "/");
      }
      if (params.isLocation) {
        url = url.replace(/^https?:\/\//, "");
      }
      return url;
    }
    var getSignHost = function(opt) {
      if (!opt.Bucket || !opt.Region)
        return "";
      var useAccelerate = opt.UseAccelerate === void 0 ? this.options.UseAccelerate : opt.UseAccelerate;
      var url = opt.Url || getUrl({
        ForcePathStyle: this.options.ForcePathStyle,
        protocol: this.options.Protocol,
        domain: this.options.Domain,
        bucket: opt.Bucket,
        region: useAccelerate ? "accelerate" : opt.Region
      });
      var urlHost = url.replace(/^https?:\/\/([^/]+)(\/.*)?$/, "$1");
      var standardHostReg = new RegExp("^([a-z\\d-]+-\\d+\\.)?(cos|cosv6|ci|pic)\\.([a-z\\d-]+)\\.myqcloud\\.com$");
      if (standardHostReg.test(urlHost))
        return urlHost;
      return "";
    };
    function getAuthorizationAsync(params, callback) {
      var headers = util.clone(params.Headers);
      var headerHost = "";
      util.each(headers, function(v, k) {
        (v === "" || ["content-type", "cache-control", "expires"].indexOf(k.toLowerCase()) > -1) && delete headers[k];
        if (k.toLowerCase() === "host")
          headerHost = v;
      });
      var forceSignHost = params.ForceSignHost === false ? false : true;
      if (!headerHost && params.SignHost && forceSignHost)
        headers.Host = params.SignHost;
      var cbDone = false;
      var cb = function(err, AuthData) {
        if (cbDone)
          return;
        cbDone = true;
        if (AuthData && AuthData.XCosSecurityToken && !AuthData.SecurityToken) {
          AuthData = util.clone(AuthData);
          AuthData.SecurityToken = AuthData.XCosSecurityToken;
          delete AuthData.XCosSecurityToken;
        }
        callback && callback(err, AuthData);
      };
      var self2 = this;
      var Bucket = params.Bucket || "";
      var Region = params.Region || "";
      var KeyName = params.Key || "";
      if (self2.options.ForcePathStyle && Bucket) {
        KeyName = Bucket + "/" + KeyName;
      }
      var Pathname = "/" + KeyName;
      var StsData = {};
      var Scope = params.Scope;
      if (!Scope) {
        var Action = params.Action || "";
        var ResourceKey = params.ResourceKey || params.Key || "";
        Scope = params.Scope || [{
          action: Action,
          bucket: Bucket,
          region: Region,
          prefix: ResourceKey
        }];
      }
      var ScopeKey = util.md5(JSON.stringify(Scope));
      self2._StsCache = self2._StsCache || [];
      (function() {
        var i, AuthData;
        for (i = self2._StsCache.length - 1; i >= 0; i--) {
          AuthData = self2._StsCache[i];
          var compareTime = Math.round(util.getSkewTime(self2.options.SystemClockOffset) / 1e3) + 30;
          if (AuthData.StartTime && compareTime < AuthData.StartTime || compareTime >= AuthData.ExpiredTime) {
            self2._StsCache.splice(i, 1);
            continue;
          }
          if (!AuthData.ScopeLimit || AuthData.ScopeLimit && AuthData.ScopeKey === ScopeKey) {
            StsData = AuthData;
            break;
          }
        }
      })();
      var calcAuthByTmpKey = function() {
        var KeyTime = "";
        if (StsData.StartTime && params.Expires)
          KeyTime = StsData.StartTime + ";" + (StsData.StartTime + params.Expires * 1);
        else if (StsData.StartTime && StsData.ExpiredTime)
          KeyTime = StsData.StartTime + ";" + StsData.ExpiredTime;
        var Authorization = util.getAuth({
          SecretId: StsData.TmpSecretId,
          SecretKey: StsData.TmpSecretKey,
          Method: params.Method,
          Pathname,
          Query: params.Query,
          Headers: headers,
          Expires: params.Expires,
          UseRawKey: self2.options.UseRawKey,
          SystemClockOffset: self2.options.SystemClockOffset,
          KeyTime,
          ForceSignHost: forceSignHost
        });
        var AuthData = {
          Authorization,
          SecurityToken: StsData.SecurityToken || StsData.XCosSecurityToken || "",
          Token: StsData.Token || "",
          ClientIP: StsData.ClientIP || "",
          ClientUA: StsData.ClientUA || ""
        };
        cb(null, AuthData);
      };
      var checkAuthError = function(AuthData) {
        if (AuthData.Authorization) {
          var formatAllow = false;
          var auth = AuthData.Authorization;
          if (auth) {
            if (auth.indexOf(" ") > -1) {
              formatAllow = false;
            } else if (auth.indexOf("q-sign-algorithm=") > -1 && auth.indexOf("q-ak=") > -1 && auth.indexOf("q-sign-time=") > -1 && auth.indexOf("q-key-time=") > -1 && auth.indexOf("q-url-param-list=") > -1) {
              formatAllow = true;
            } else {
              try {
                auth = atob(auth);
                if (auth.indexOf("a=") > -1 && auth.indexOf("k=") > -1 && auth.indexOf("t=") > -1 && auth.indexOf("r=") > -1 && auth.indexOf("b=") > -1) {
                  formatAllow = true;
                }
              } catch (e) {
              }
            }
          }
          if (!formatAllow)
            return util.error(new Error("getAuthorization callback params format error"));
        } else {
          if (!AuthData.TmpSecretId)
            return util.error(new Error('getAuthorization callback params missing "TmpSecretId"'));
          if (!AuthData.TmpSecretKey)
            return util.error(new Error('getAuthorization callback params missing "TmpSecretKey"'));
          if (!AuthData.SecurityToken && !AuthData.XCosSecurityToken)
            return util.error(new Error('getAuthorization callback params missing "SecurityToken"'));
          if (!AuthData.ExpiredTime)
            return util.error(new Error('getAuthorization callback params missing "ExpiredTime"'));
          if (AuthData.ExpiredTime && AuthData.ExpiredTime.toString().length !== 10)
            return util.error(new Error('getAuthorization callback params "ExpiredTime" should be 10 digits'));
          if (AuthData.StartTime && AuthData.StartTime.toString().length !== 10)
            return util.error(new Error('getAuthorization callback params "StartTime" should be 10 StartTime'));
        }
        return false;
      };
      if (StsData.ExpiredTime && StsData.ExpiredTime - util.getSkewTime(self2.options.SystemClockOffset) / 1e3 > 60) {
        calcAuthByTmpKey();
      } else if (self2.options.getAuthorization) {
        self2.options.getAuthorization.call(self2, {
          Bucket,
          Region,
          Method: params.Method,
          Key: KeyName,
          Pathname,
          Query: params.Query,
          Headers: headers,
          Scope,
          SystemClockOffset: self2.options.SystemClockOffset,
          ForceSignHost: forceSignHost
        }, function(AuthData) {
          if (typeof AuthData === "string")
            AuthData = { Authorization: AuthData };
          var AuthError = checkAuthError(AuthData);
          if (AuthError)
            return cb(AuthError);
          if (AuthData.Authorization) {
            cb(null, AuthData);
          } else {
            StsData = AuthData || {};
            StsData.Scope = Scope;
            StsData.ScopeKey = ScopeKey;
            self2._StsCache.push(StsData);
            calcAuthByTmpKey();
          }
        });
      } else if (self2.options.getSTS) {
        self2.options.getSTS.call(self2, {
          Bucket,
          Region
        }, function(data) {
          StsData = data || {};
          StsData.Scope = Scope;
          StsData.ScopeKey = ScopeKey;
          if (!StsData.TmpSecretId)
            StsData.TmpSecretId = StsData.SecretId;
          if (!StsData.TmpSecretKey)
            StsData.TmpSecretKey = StsData.SecretKey;
          var AuthError = checkAuthError(StsData);
          if (AuthError)
            return cb(AuthError);
          self2._StsCache.push(StsData);
          calcAuthByTmpKey();
        });
      } else {
        return function() {
          var Authorization = util.getAuth({
            SecretId: params.SecretId || self2.options.SecretId,
            SecretKey: params.SecretKey || self2.options.SecretKey,
            Method: params.Method,
            Pathname,
            Query: params.Query,
            Headers: headers,
            Expires: params.Expires,
            UseRawKey: self2.options.UseRawKey,
            SystemClockOffset: self2.options.SystemClockOffset,
            ForceSignHost: forceSignHost
          });
          var AuthData = {
            Authorization,
            SecurityToken: self2.options.SecurityToken || self2.options.XCosSecurityToken
          };
          cb(null, AuthData);
          return AuthData;
        }();
      }
      return "";
    }
    function allowRetry(err) {
      var allowRetry2 = false;
      var isTimeError = false;
      var serverDate = err.headers && (err.headers.date || err.headers.Date) || err.error && err.error.ServerTime;
      try {
        var errorCode = err.error.Code;
        var errorMessage = err.error.Message;
        if (errorCode === "RequestTimeTooSkewed" || errorCode === "AccessDenied" && errorMessage === "Request has expired") {
          isTimeError = true;
        }
      } catch (e) {
      }
      if (err) {
        if (isTimeError && serverDate) {
          var serverTime = Date.parse(serverDate);
          if (this.options.CorrectClockSkew && Math.abs(util.getSkewTime(this.options.SystemClockOffset) - serverTime) >= 3e4) {
            console.error("error: Local time is too skewed.");
            this.options.SystemClockOffset = serverTime - Date.now();
            allowRetry2 = true;
          }
        } else if (Math.floor(err.statusCode / 100) === 5) {
          allowRetry2 = true;
        }
      }
      return allowRetry2;
    }
    function submitRequest(params, callback) {
      var self2 = this;
      !params.headers && (params.headers = {});
      !params.qs && (params.qs = {});
      params.VersionId && (params.qs.versionId = params.VersionId);
      params.qs = util.clearKey(params.qs);
      params.headers && (params.headers = util.clearKey(params.headers));
      params.qs && (params.qs = util.clearKey(params.qs));
      var Query = util.clone(params.qs);
      params.action && (Query[params.action] = "");
      var paramsUrl = params.url || params.Url;
      var SignHost = params.SignHost || getSignHost.call(this, { Bucket: params.Bucket, Region: params.Region, Url: paramsUrl });
      var next = function(tryTimes) {
        var oldClockOffset = self2.options.SystemClockOffset;
        getAuthorizationAsync.call(self2, {
          Bucket: params.Bucket || "",
          Region: params.Region || "",
          Method: params.method,
          Key: params.Key,
          Query,
          Headers: params.headers,
          SignHost,
          Action: params.Action,
          ResourceKey: params.ResourceKey,
          Scope: params.Scope,
          ForceSignHost: self2.options.ForceSignHost
        }, function(err, AuthData) {
          if (err) {
            callback(err);
            return;
          }
          params.AuthData = AuthData;
          _submitRequest.call(self2, params, function(err2, data) {
            if (err2 && tryTimes < 2 && (oldClockOffset !== self2.options.SystemClockOffset || allowRetry.call(self2, err2))) {
              if (params.headers) {
                delete params.headers.Authorization;
                delete params.headers["token"];
                delete params.headers["clientIP"];
                delete params.headers["clientUA"];
                params.headers["x-cos-security-token"] && delete params.headers["x-cos-security-token"];
                params.headers["x-ci-security-token"] && delete params.headers["x-ci-security-token"];
              }
              next(tryTimes + 1);
            } else {
              callback(err2, data);
            }
          });
        });
      };
      next(1);
    }
    function _submitRequest(params, callback) {
      var self2 = this;
      var TaskId = params.TaskId;
      if (TaskId && !self2._isRunningTask(TaskId))
        return;
      var bucket = params.Bucket;
      var region = params.Region;
      var object = params.Key;
      var method2 = params.method || "GET";
      var url = params.Url || params.url;
      var body = params.body;
      var rawBody = params.rawBody;
      if (self2.options.UseAccelerate) {
        region = "accelerate";
      }
      url = url || getUrl({
        ForcePathStyle: self2.options.ForcePathStyle,
        protocol: self2.options.Protocol,
        domain: self2.options.Domain,
        bucket,
        region,
        object
      });
      if (params.action) {
        url = url + "?" + params.action;
      }
      if (params.qsStr) {
        if (url.indexOf("?") > -1) {
          url = url + "&" + params.qsStr;
        } else {
          url = url + "?" + params.qsStr;
        }
      }
      var opt = {
        method: method2,
        url,
        headers: params.headers,
        qs: params.qs,
        body
      };
      var token = "x-cos-security-token";
      if (util.isCIHost(url)) {
        token = "x-ci-security-token";
      }
      opt.headers.Authorization = params.AuthData.Authorization;
      params.AuthData.Token && (opt.headers["token"] = params.AuthData.Token);
      params.AuthData.ClientIP && (opt.headers["clientIP"] = params.AuthData.ClientIP);
      params.AuthData.ClientUA && (opt.headers["clientUA"] = params.AuthData.ClientUA);
      params.AuthData.SecurityToken && (opt.headers[token] = params.AuthData.SecurityToken);
      opt.headers && (opt.headers = util.clearKey(opt.headers));
      opt = util.clearKey(opt);
      if (params.onProgress && typeof params.onProgress === "function") {
        var contentLength = body && (body.size || body.length) || 0;
        opt.onProgress = function(e) {
          if (TaskId && !self2._isRunningTask(TaskId))
            return;
          var loaded = e ? e.loaded : 0;
          params.onProgress({ loaded, total: contentLength });
        };
      }
      if (params.onDownloadProgress) {
        opt.onDownloadProgress = params.onDownloadProgress;
      }
      if (params.DataType) {
        opt.dataType = params.DataType;
      }
      if (this.options.Timeout) {
        opt.timeout = this.options.Timeout;
      }
      self2.options.ForcePathStyle && (opt.pathStyle = self2.options.ForcePathStyle);
      self2.emit("before-send", opt);
      var sender = (self2.options.Request || REQUEST)(opt, function(r) {
        if (r.error === "abort")
          return;
        var receive = {
          options: opt,
          error: err,
          statusCode: response && response.statusCode || 0,
          headers: response && response.headers || {},
          body: body2
        };
        self2.emit("after-receive", receive);
        err = receive.error;
        body2 = receive.body;
        response = {
          statusCode: receive.statusCode,
          headers: receive.headers
        };
        self2.emit("after-receive", r);
        var response = { statusCode: r.statusCode, statusMessage: r.statusMessage, headers: r.headers };
        var err = r.error;
        var body2 = r.body;
        var hasReturned;
        var cb = function(err2, data) {
          TaskId && self2.off("inner-kill-task", killTask);
          if (hasReturned)
            return;
          hasReturned = true;
          var attrs = {};
          response && response.statusCode && (attrs.statusCode = response.statusCode);
          response && response.headers && (attrs.headers = response.headers);
          if (err2) {
            err2 = util.extend(err2 || {}, attrs);
            callback(err2, null);
          } else {
            data = util.extend(data || {}, attrs);
            callback(null, data);
          }
          sender = null;
        };
        if (err)
          return cb(util.error(err));
        var statusCode = response.statusCode;
        var statusSuccess = Math.floor(statusCode / 100) === 2;
        if (rawBody && statusSuccess)
          return cb(null, { body: body2 });
        var json;
        try {
          json = body2 && body2.indexOf("<") > -1 && body2.indexOf(">") > -1 && util.xml2json(body2) || {};
        } catch (e) {
          json = {};
        }
        var xmlError = json && json.Error;
        if (statusSuccess) {
          cb(null, json);
        } else if (xmlError) {
          cb(util.error(new Error(xmlError.Message), { code: xmlError.Code, error: xmlError }));
        } else if (statusCode) {
          cb(util.error(new Error(response.statusMessage), { code: "" + statusCode }));
        } else if (statusCode) {
          cb(util.error(new Error("statusCode error")));
        }
      });
      var killTask = function(data) {
        if (data.TaskId === TaskId) {
          sender && sender.abort && sender.abort();
          self2.off("inner-kill-task", killTask);
        }
      };
      TaskId && self2.on("inner-kill-task", killTask);
    }
    var API_MAP = {
      getService,
      putBucket,
      headBucket,
      getBucket,
      deleteBucket,
      putBucketAcl,
      getBucketAcl,
      putBucketCors,
      getBucketCors,
      deleteBucketCors,
      getBucketLocation,
      getBucketPolicy,
      putBucketPolicy,
      deleteBucketPolicy,
      putBucketTagging,
      getBucketTagging,
      deleteBucketTagging,
      putBucketLifecycle,
      getBucketLifecycle,
      deleteBucketLifecycle,
      putBucketVersioning,
      getBucketVersioning,
      putBucketReplication,
      getBucketReplication,
      deleteBucketReplication,
      putBucketWebsite,
      getBucketWebsite,
      deleteBucketWebsite,
      putBucketReferer,
      getBucketReferer,
      putBucketDomain,
      getBucketDomain,
      deleteBucketDomain,
      putBucketOrigin,
      getBucketOrigin,
      deleteBucketOrigin,
      putBucketLogging,
      getBucketLogging,
      putBucketInventory,
      getBucketInventory,
      listBucketInventory,
      deleteBucketInventory,
      putBucketAccelerate,
      getBucketAccelerate,
      putBucketEncryption,
      getBucketEncryption,
      deleteBucketEncryption,
      getObject,
      headObject,
      listObjectVersions,
      putObject,
      deleteObject,
      getObjectAcl,
      putObjectAcl,
      optionsObject,
      putObjectCopy,
      deleteMultipleObject,
      restoreObject,
      putObjectTagging,
      getObjectTagging,
      deleteObjectTagging,
      selectObjectContent,
      appendObject,
      uploadPartCopy,
      multipartInit,
      multipartUpload,
      multipartComplete,
      multipartList,
      multipartListPart,
      multipartAbort,
      request,
      getObjectUrl,
      getAuth
    };
    function warnOldApi(apiName, fn, proto) {
      util.each(["Cors", "Acl"], function(suffix) {
        if (apiName.slice(-suffix.length) === suffix) {
          var oldName = apiName.slice(0, -suffix.length) + suffix.toUpperCase();
          var apiFn = util.apiWrapper(apiName, fn);
          var warned = false;
          proto[oldName] = function() {
            !warned && console.warn("warning: cos." + oldName + " has been deprecated. Please Use cos." + apiName + " instead.");
            warned = true;
            apiFn.apply(this, arguments);
          };
        }
      });
    }
    module2.exports.init = function(COS, task) {
      task.transferToTaskMethod(API_MAP, "putObject");
      util.each(API_MAP, function(fn, apiName) {
        COS.prototype[apiName] = util.apiWrapper(apiName, fn);
        warnOldApi(apiName, fn, COS.prototype);
      });
    };
  }
});

// node_modules/cos-js-sdk-v5/src/async.js
var require_async = __commonJS({
  "node_modules/cos-js-sdk-v5/src/async.js"(exports2, module2) {
    var eachLimit = function(arr, limit, iterator, callback) {
      callback = callback || function() {
      };
      if (!arr.length || limit <= 0) {
        return callback();
      }
      var completed = 0;
      var started = 0;
      var running = 0;
      (function replenish() {
        if (completed >= arr.length) {
          return callback();
        }
        while (running < limit && started < arr.length) {
          started += 1;
          running += 1;
          iterator(arr[started - 1], function(err) {
            if (err) {
              callback(err);
              callback = function() {
              };
            } else {
              completed += 1;
              running -= 1;
              if (completed >= arr.length) {
                callback();
              } else {
                replenish();
              }
            }
          });
        }
      })();
    };
    var retry = function(times, iterator, callback) {
      var next = function(index) {
        iterator(function(err, data) {
          if (err && index < times) {
            next(index + 1);
          } else {
            callback(err, data);
          }
        });
      };
      if (times < 1) {
        callback();
      } else {
        next(1);
      }
    };
    var async = {
      eachLimit,
      retry
    };
    module2.exports = async;
  }
});

// node_modules/cos-js-sdk-v5/src/advance.js
var require_advance = __commonJS({
  "node_modules/cos-js-sdk-v5/src/advance.js"(exports2, module2) {
    var session = require_session();
    var Async = require_async();
    var EventProxy = require_event().EventProxy;
    var util = require_util();
    function sliceUploadFile(params, callback) {
      var self2 = this;
      var ep = new EventProxy();
      var TaskId = params.TaskId;
      var Bucket = params.Bucket;
      var Region = params.Region;
      var Key = params.Key;
      var Body = params.Body;
      var ChunkSize = params.ChunkSize || params.SliceSize || self2.options.ChunkSize;
      var AsyncLimit = params.AsyncLimit;
      var StorageClass = params.StorageClass;
      var ServerSideEncryption = params.ServerSideEncryption;
      var FileSize;
      var onProgress;
      var onHashProgress = params.onHashProgress;
      ep.on("error", function(err) {
        if (!self2._isRunningTask(TaskId))
          return;
        err.UploadId = params.UploadData.UploadId || "";
        return callback(err);
      });
      ep.on("upload_complete", function(UploadCompleteData) {
        var _UploadCompleteData = util.extend({
          UploadId: params.UploadData.UploadId || ""
        }, UploadCompleteData);
        callback(null, _UploadCompleteData);
      });
      ep.on("upload_slice_complete", function(UploadData) {
        var metaHeaders = {};
        util.each(params.Headers, function(val, k) {
          var shortKey = k.toLowerCase();
          if (shortKey.indexOf("x-cos-meta-") === 0 || shortKey === "pic-operations")
            metaHeaders[k] = val;
        });
        uploadSliceComplete.call(self2, {
          Bucket,
          Region,
          Key,
          UploadId: UploadData.UploadId,
          SliceList: UploadData.SliceList,
          Headers: metaHeaders
        }, function(err, data) {
          if (!self2._isRunningTask(TaskId))
            return;
          session.removeUsing(UploadData.UploadId);
          if (err) {
            onProgress(null, true);
            return ep.emit("error", err);
          }
          session.removeUploadId.call(self2, UploadData.UploadId);
          onProgress({ loaded: FileSize, total: FileSize }, true);
          ep.emit("upload_complete", data);
        });
      });
      ep.on("get_upload_data_finish", function(UploadData) {
        var uuid = session.getFileId(Body, params.ChunkSize, Bucket, Key);
        uuid && session.saveUploadId.call(self2, uuid, UploadData.UploadId, self2.options.UploadIdCacheLimit);
        session.setUsing(UploadData.UploadId);
        onProgress(null, true);
        uploadSliceList.call(self2, {
          TaskId,
          Bucket,
          Region,
          Key,
          Body,
          FileSize,
          SliceSize: ChunkSize,
          AsyncLimit,
          ServerSideEncryption,
          UploadData,
          Headers: params.Headers,
          onProgress
        }, function(err, data) {
          if (!self2._isRunningTask(TaskId))
            return;
          if (err) {
            onProgress(null, true);
            return ep.emit("error", err);
          }
          ep.emit("upload_slice_complete", data);
        });
      });
      ep.on("get_file_size_finish", function() {
        onProgress = util.throttleOnProgress.call(self2, FileSize, params.onProgress);
        if (params.UploadData.UploadId) {
          ep.emit("get_upload_data_finish", params.UploadData);
        } else {
          var _params = util.extend({
            TaskId,
            Bucket,
            Region,
            Key,
            Headers: params.Headers,
            StorageClass,
            Body,
            FileSize,
            SliceSize: ChunkSize,
            onHashProgress
          }, params);
          getUploadIdAndPartList.call(self2, _params, function(err, UploadData) {
            if (!self2._isRunningTask(TaskId))
              return;
            if (err)
              return ep.emit("error", err);
            params.UploadData.UploadId = UploadData.UploadId;
            params.UploadData.PartList = UploadData.PartList;
            ep.emit("get_upload_data_finish", params.UploadData);
          });
        }
      });
      FileSize = params.ContentLength;
      delete params.ContentLength;
      !params.Headers && (params.Headers = {});
      util.each(params.Headers, function(item, key) {
        if (key.toLowerCase() === "content-length") {
          delete params.Headers[key];
        }
      });
      (function() {
        var SIZE = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 1024 * 2, 1024 * 4, 1024 * 5];
        var AutoChunkSize = 1024 * 1024;
        for (var i = 0; i < SIZE.length; i++) {
          AutoChunkSize = SIZE[i] * 1024 * 1024;
          if (FileSize / AutoChunkSize <= self2.options.MaxPartNumber)
            break;
        }
        params.ChunkSize = params.SliceSize = ChunkSize = Math.max(ChunkSize, AutoChunkSize);
      })();
      if (FileSize === 0) {
        params.Body = "";
        params.ContentLength = 0;
        params.SkipTask = true;
        self2.putObject(params, callback);
      } else {
        ep.emit("get_file_size_finish");
      }
    }
    function getUploadIdAndPartList(params, callback) {
      var TaskId = params.TaskId;
      var Bucket = params.Bucket;
      var Region = params.Region;
      var Key = params.Key;
      var StorageClass = params.StorageClass;
      var self2 = this;
      var ETagMap = {};
      var FileSize = params.FileSize;
      var SliceSize = params.SliceSize;
      var SliceCount = Math.ceil(FileSize / SliceSize);
      var FinishSliceCount = 0;
      var FinishSize = 0;
      var onHashProgress = util.throttleOnProgress.call(self2, FileSize, params.onHashProgress);
      var getChunkETag = function(PartNumber, callback2) {
        var start = SliceSize * (PartNumber - 1);
        var end = Math.min(start + SliceSize, FileSize);
        var ChunkSize = end - start;
        if (ETagMap[PartNumber]) {
          callback2(null, {
            PartNumber,
            ETag: ETagMap[PartNumber],
            Size: ChunkSize
          });
        } else {
          util.fileSlice(params.Body, start, end, false, function(chunkItem) {
            util.getFileMd5(chunkItem, function(err, md5) {
              if (err)
                return callback2(util.error(err));
              var ETag = '"' + md5 + '"';
              ETagMap[PartNumber] = ETag;
              FinishSliceCount += 1;
              FinishSize += ChunkSize;
              onHashProgress({ loaded: FinishSize, total: FileSize });
              callback2(null, {
                PartNumber,
                ETag,
                Size: ChunkSize
              });
            });
          });
        }
      };
      var isAvailableUploadList = function(PartList, callback2) {
        var PartCount = PartList.length;
        if (PartCount === 0) {
          return callback2(null, true);
        }
        if (PartCount > SliceCount) {
          return callback2(null, false);
        }
        if (PartCount > 1) {
          var PartSliceSize = Math.max(PartList[0].Size, PartList[1].Size);
          if (PartSliceSize !== SliceSize) {
            return callback2(null, false);
          }
        }
        var next = function(index) {
          if (index < PartCount) {
            var Part = PartList[index];
            getChunkETag(Part.PartNumber, function(err, chunk) {
              if (chunk && chunk.ETag === Part.ETag && chunk.Size === Part.Size) {
                next(index + 1);
              } else {
                callback2(null, false);
              }
            });
          } else {
            callback2(null, true);
          }
        };
        next(0);
      };
      var ep = new EventProxy();
      ep.on("error", function(errData) {
        if (!self2._isRunningTask(TaskId))
          return;
        return callback(errData);
      });
      ep.on("upload_id_available", function(UploadData) {
        var map = {};
        var list = [];
        util.each(UploadData.PartList, function(item2) {
          map[item2.PartNumber] = item2;
        });
        for (var PartNumber = 1; PartNumber <= SliceCount; PartNumber++) {
          var item = map[PartNumber];
          if (item) {
            item.PartNumber = PartNumber;
            item.Uploaded = true;
          } else {
            item = {
              PartNumber,
              ETag: null,
              Uploaded: false
            };
          }
          list.push(item);
        }
        UploadData.PartList = list;
        callback(null, UploadData);
      });
      ep.on("no_available_upload_id", function() {
        if (!self2._isRunningTask(TaskId))
          return;
        var _params = util.extend({
          Bucket,
          Region,
          Key,
          Query: util.clone(params.Query),
          StorageClass,
          Body: params.Body
        }, params);
        var headers = util.clone(params.Headers);
        delete headers["x-cos-mime-limit"];
        _params.Headers = headers;
        self2.multipartInit(_params, function(err, data) {
          if (!self2._isRunningTask(TaskId))
            return;
          if (err)
            return ep.emit("error", err);
          var UploadId = data.UploadId;
          if (!UploadId) {
            return callback(util.error(new Error("no such upload id")));
          }
          ep.emit("upload_id_available", { UploadId, PartList: [] });
        });
      });
      ep.on("has_and_check_upload_id", function(UploadIdList) {
        UploadIdList = UploadIdList.reverse();
        Async.eachLimit(UploadIdList, 1, function(UploadId, asyncCallback) {
          if (!self2._isRunningTask(TaskId))
            return;
          if (session.using[UploadId]) {
            asyncCallback();
            return;
          }
          wholeMultipartListPart.call(self2, {
            Bucket,
            Region,
            Key,
            UploadId
          }, function(err, PartListData) {
            if (!self2._isRunningTask(TaskId))
              return;
            if (err) {
              session.removeUsing(UploadId);
              return ep.emit("error", err);
            }
            var PartList = PartListData.PartList;
            PartList.forEach(function(item) {
              item.PartNumber *= 1;
              item.Size *= 1;
              item.ETag = item.ETag || "";
            });
            isAvailableUploadList(PartList, function(err2, isAvailable) {
              if (!self2._isRunningTask(TaskId))
                return;
              if (err2)
                return ep.emit("error", err2);
              if (isAvailable) {
                asyncCallback({
                  UploadId,
                  PartList
                });
              } else {
                asyncCallback();
              }
            });
          });
        }, function(AvailableUploadData) {
          if (!self2._isRunningTask(TaskId))
            return;
          onHashProgress(null, true);
          if (AvailableUploadData && AvailableUploadData.UploadId) {
            ep.emit("upload_id_available", AvailableUploadData);
          } else {
            ep.emit("no_available_upload_id");
          }
        });
      });
      ep.on("seek_local_avail_upload_id", function(RemoteUploadIdList) {
        var uuid = session.getFileId(params.Body, params.ChunkSize, Bucket, Key);
        var LocalUploadIdList = session.getUploadIdList.call(self2, uuid);
        if (!uuid || !LocalUploadIdList) {
          ep.emit("has_and_check_upload_id", RemoteUploadIdList);
          return;
        }
        var next = function(index) {
          if (index >= LocalUploadIdList.length) {
            ep.emit("has_and_check_upload_id", RemoteUploadIdList);
            return;
          }
          var UploadId = LocalUploadIdList[index];
          if (!util.isInArray(RemoteUploadIdList, UploadId)) {
            session.removeUploadId.call(self2, UploadId);
            next(index + 1);
            return;
          }
          if (session.using[UploadId]) {
            next(index + 1);
            return;
          }
          wholeMultipartListPart.call(self2, {
            Bucket,
            Region,
            Key,
            UploadId
          }, function(err, PartListData) {
            if (!self2._isRunningTask(TaskId))
              return;
            if (err) {
              session.removeUploadId.call(self2, UploadId);
              next(index + 1);
            } else {
              ep.emit("upload_id_available", {
                UploadId,
                PartList: PartListData.PartList
              });
            }
          });
        };
        next(0);
      });
      ep.on("get_remote_upload_id_list", function() {
        wholeMultipartList.call(self2, {
          Bucket,
          Region,
          Key
        }, function(err, data) {
          if (!self2._isRunningTask(TaskId))
            return;
          if (err)
            return ep.emit("error", err);
          var RemoteUploadIdList = util.filter(data.UploadList, function(item) {
            return item.Key === Key && (!StorageClass || item.StorageClass.toUpperCase() === StorageClass.toUpperCase());
          }).reverse().map(function(item) {
            return item.UploadId || item.UploadID;
          });
          if (RemoteUploadIdList.length) {
            ep.emit("seek_local_avail_upload_id", RemoteUploadIdList);
          } else {
            var uuid = session.getFileId(params.Body, params.ChunkSize, Bucket, Key), LocalUploadIdList;
            if (uuid && (LocalUploadIdList = session.getUploadIdList.call(self2, uuid))) {
              util.each(LocalUploadIdList, function(UploadId) {
                session.removeUploadId.call(self2, UploadId);
              });
            }
            ep.emit("no_available_upload_id");
          }
        });
      });
      ep.emit("get_remote_upload_id_list");
    }
    function wholeMultipartList(params, callback) {
      var self2 = this;
      var UploadList = [];
      var sendParams = {
        Bucket: params.Bucket,
        Region: params.Region,
        Prefix: params.Key
      };
      var next = function() {
        self2.multipartList(sendParams, function(err, data) {
          if (err)
            return callback(err);
          UploadList.push.apply(UploadList, data.Upload || []);
          if (data.IsTruncated === "true") {
            sendParams.KeyMarker = data.NextKeyMarker;
            sendParams.UploadIdMarker = data.NextUploadIdMarker;
            next();
          } else {
            callback(null, { UploadList });
          }
        });
      };
      next();
    }
    function wholeMultipartListPart(params, callback) {
      var self2 = this;
      var PartList = [];
      var sendParams = {
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        UploadId: params.UploadId
      };
      var next = function() {
        self2.multipartListPart(sendParams, function(err, data) {
          if (err)
            return callback(err);
          PartList.push.apply(PartList, data.Part || []);
          if (data.IsTruncated === "true") {
            sendParams.PartNumberMarker = data.NextPartNumberMarker;
            next();
          } else {
            callback(null, { PartList });
          }
        });
      };
      next();
    }
    function uploadSliceList(params, cb) {
      var self2 = this;
      var TaskId = params.TaskId;
      var Bucket = params.Bucket;
      var Region = params.Region;
      var Key = params.Key;
      var UploadData = params.UploadData;
      var FileSize = params.FileSize;
      var SliceSize = params.SliceSize;
      var ChunkParallel = Math.min(params.AsyncLimit || self2.options.ChunkParallelLimit || 1, 256);
      var Body = params.Body;
      var SliceCount = Math.ceil(FileSize / SliceSize);
      var FinishSize = 0;
      var ServerSideEncryption = params.ServerSideEncryption;
      var Headers = params.Headers;
      var needUploadSlices = util.filter(UploadData.PartList, function(SliceItem) {
        if (SliceItem["Uploaded"]) {
          FinishSize += SliceItem["PartNumber"] >= SliceCount ? FileSize % SliceSize || SliceSize : SliceSize;
        }
        return !SliceItem["Uploaded"];
      });
      var onProgress = params.onProgress;
      Async.eachLimit(needUploadSlices, ChunkParallel, function(SliceItem, asyncCallback) {
        if (!self2._isRunningTask(TaskId))
          return;
        var PartNumber = SliceItem["PartNumber"];
        var currentSize = Math.min(FileSize, SliceItem["PartNumber"] * SliceSize) - (SliceItem["PartNumber"] - 1) * SliceSize;
        var preAddSize = 0;
        uploadSliceItem.call(self2, {
          TaskId,
          Bucket,
          Region,
          Key,
          SliceSize,
          FileSize,
          PartNumber,
          ServerSideEncryption,
          Body,
          UploadData,
          Headers,
          onProgress: function(data) {
            FinishSize += data.loaded - preAddSize;
            preAddSize = data.loaded;
            onProgress({ loaded: FinishSize, total: FileSize });
          }
        }, function(err, data) {
          if (!self2._isRunningTask(TaskId))
            return;
          if (!err && !data.ETag)
            err = 'get ETag error, please add "ETag" to CORS ExposeHeader setting.( \u83B7\u53D6ETag\u5931\u8D25\uFF0C\u8BF7\u5728CORS ExposeHeader\u8BBE\u7F6E\u4E2D\u6DFB\u52A0ETag\uFF0C\u8BF7\u53C2\u8003\u6587\u6863\uFF1Ahttps://cloud.tencent.com/document/product/436/13318 )';
          if (err) {
            FinishSize -= preAddSize;
          } else {
            FinishSize += currentSize - preAddSize;
            SliceItem.ETag = data.ETag;
          }
          onProgress({ loaded: FinishSize, total: FileSize });
          asyncCallback(err || null, data);
        });
      }, function(err) {
        if (!self2._isRunningTask(TaskId))
          return;
        if (err)
          return cb(err);
        cb(null, {
          UploadId: UploadData.UploadId,
          SliceList: UploadData.PartList
        });
      });
    }
    function uploadSliceItem(params, callback) {
      var self2 = this;
      var TaskId = params.TaskId;
      var Bucket = params.Bucket;
      var Region = params.Region;
      var Key = params.Key;
      var FileSize = params.FileSize;
      var FileBody = params.Body;
      var PartNumber = params.PartNumber * 1;
      var SliceSize = params.SliceSize;
      var ServerSideEncryption = params.ServerSideEncryption;
      var UploadData = params.UploadData;
      var Headers = params.Headers || {};
      var ChunkRetryTimes = self2.options.ChunkRetryTimes + 1;
      var start = SliceSize * (PartNumber - 1);
      var ContentLength = SliceSize;
      var end = start + SliceSize;
      if (end > FileSize) {
        end = FileSize;
        ContentLength = end - start;
      }
      var headersWhiteList = ["x-cos-traffic-limit", "x-cos-mime-limit"];
      var headers = {};
      util.each(Headers, function(v, k) {
        if (headersWhiteList.indexOf(k) > -1) {
          headers[k] = v;
        }
      });
      var PartItem = UploadData.PartList[PartNumber - 1];
      Async.retry(ChunkRetryTimes, function(tryCallback) {
        if (!self2._isRunningTask(TaskId))
          return;
        util.fileSlice(FileBody, start, end, true, function(Body) {
          self2.multipartUpload({
            TaskId,
            Bucket,
            Region,
            Key,
            ContentLength,
            PartNumber,
            UploadId: UploadData.UploadId,
            ServerSideEncryption,
            Body,
            Headers: headers,
            onProgress: params.onProgress
          }, function(err, data) {
            if (!self2._isRunningTask(TaskId))
              return;
            if (err)
              return tryCallback(err);
            PartItem.Uploaded = true;
            return tryCallback(null, data);
          });
        });
      }, function(err, data) {
        if (!self2._isRunningTask(TaskId))
          return;
        return callback(err, data);
      });
    }
    function uploadSliceComplete(params, callback) {
      var Bucket = params.Bucket;
      var Region = params.Region;
      var Key = params.Key;
      var UploadId = params.UploadId;
      var SliceList = params.SliceList;
      var self2 = this;
      var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;
      var Headers = params.Headers;
      var Parts = SliceList.map(function(item) {
        return {
          PartNumber: item.PartNumber,
          ETag: item.ETag
        };
      });
      Async.retry(ChunkRetryTimes, function(tryCallback) {
        self2.multipartComplete({
          Bucket,
          Region,
          Key,
          UploadId,
          Parts,
          Headers
        }, tryCallback);
      }, function(err, data) {
        callback(err, data);
      });
    }
    function abortUploadTask(params, callback) {
      var Bucket = params.Bucket;
      var Region = params.Region;
      var Key = params.Key;
      var UploadId = params.UploadId;
      var Level = params.Level || "task";
      var AsyncLimit = params.AsyncLimit;
      var self2 = this;
      var ep = new EventProxy();
      ep.on("error", function(errData) {
        return callback(errData);
      });
      ep.on("get_abort_array", function(AbortArray) {
        abortUploadTaskArray.call(self2, {
          Bucket,
          Region,
          Key,
          Headers: params.Headers,
          AsyncLimit,
          AbortArray
        }, callback);
      });
      if (Level === "bucket") {
        wholeMultipartList.call(self2, {
          Bucket,
          Region
        }, function(err, data) {
          if (err)
            return callback(err);
          ep.emit("get_abort_array", data.UploadList || []);
        });
      } else if (Level === "file") {
        if (!Key)
          return callback(util.error(new Error("abort_upload_task_no_key")));
        wholeMultipartList.call(self2, {
          Bucket,
          Region,
          Key
        }, function(err, data) {
          if (err)
            return callback(err);
          ep.emit("get_abort_array", data.UploadList || []);
        });
      } else if (Level === "task") {
        if (!UploadId)
          return callback(util.error(new Error("abort_upload_task_no_id")));
        if (!Key)
          return callback(util.error(new Error("abort_upload_task_no_key")));
        ep.emit("get_abort_array", [{
          Key,
          UploadId
        }]);
      } else {
        return callback(util.error(new Error("abort_unknown_level")));
      }
    }
    function abortUploadTaskArray(params, callback) {
      var Bucket = params.Bucket;
      var Region = params.Region;
      var Key = params.Key;
      var AbortArray = params.AbortArray;
      var AsyncLimit = params.AsyncLimit || 1;
      var self2 = this;
      var index = 0;
      var resultList = new Array(AbortArray.length);
      Async.eachLimit(AbortArray, AsyncLimit, function(AbortItem, nextItem) {
        var eachIndex = index;
        if (Key && Key !== AbortItem.Key) {
          resultList[eachIndex] = { error: { KeyNotMatch: true } };
          nextItem(null);
          return;
        }
        var UploadId = AbortItem.UploadId || AbortItem.UploadID;
        self2.multipartAbort({
          Bucket,
          Region,
          Key: AbortItem.Key,
          Headers: params.Headers,
          UploadId
        }, function(err) {
          var task = {
            Bucket,
            Region,
            Key: AbortItem.Key,
            UploadId
          };
          resultList[eachIndex] = { error: err, task };
          nextItem(null);
        });
        index++;
      }, function(err) {
        if (err)
          return callback(err);
        var successList = [];
        var errorList = [];
        for (var i = 0, len = resultList.length; i < len; i++) {
          var item = resultList[i];
          if (item["task"]) {
            if (item["error"]) {
              errorList.push(item["task"]);
            } else {
              successList.push(item["task"]);
            }
          }
        }
        return callback(null, {
          successList,
          errorList
        });
      });
    }
    function uploadFile(params, callback) {
      var self2 = this;
      var SliceSize = params.SliceSize === void 0 ? self2.options.SliceSize : params.SliceSize;
      var taskList = [];
      var Body = params.Body;
      var FileSize = Body.size || Body.length || 0;
      var fileInfo = { TaskId: "" };
      util.each(params, function(v, k) {
        if (typeof v !== "object" && typeof v !== "function") {
          fileInfo[k] = v;
        }
      });
      var _onTaskReady = params.onTaskReady;
      var onTaskReady = function(tid) {
        fileInfo.TaskId = tid;
        _onTaskReady && _onTaskReady(tid);
      };
      params.onTaskReady = onTaskReady;
      var _onFileFinish = params.onFileFinish;
      var onFileFinish = function(err, data) {
        _onFileFinish && _onFileFinish(err, data, fileInfo);
        callback && callback(err, data);
      };
      var api = FileSize > SliceSize ? "sliceUploadFile" : "putObject";
      taskList.push({
        api,
        params,
        callback: onFileFinish
      });
      self2._addTasks(taskList);
    }
    function uploadFiles(params, callback) {
      var self2 = this;
      var SliceSize = params.SliceSize === void 0 ? self2.options.SliceSize : params.SliceSize;
      var TotalSize = 0;
      var TotalFinish = 0;
      var onTotalProgress = util.throttleOnProgress.call(self2, TotalFinish, params.onProgress);
      var unFinishCount = params.files.length;
      var _onTotalFileFinish = params.onFileFinish;
      var resultList = Array(unFinishCount);
      var onTotalFileFinish = function(err, data, options) {
        onTotalProgress(null, true);
        _onTotalFileFinish && _onTotalFileFinish(err, data, options);
        resultList[options.Index] = {
          options,
          error: err,
          data
        };
        if (--unFinishCount <= 0 && callback) {
          callback(null, { files: resultList });
        }
      };
      var taskList = [];
      util.each(params.files, function(fileParams, index) {
        (function() {
          var Body = fileParams.Body;
          var FileSize = Body.size || Body.length || 0;
          var fileInfo = { Index: index, TaskId: "" };
          TotalSize += FileSize;
          util.each(fileParams, function(v, k) {
            if (typeof v !== "object" && typeof v !== "function") {
              fileInfo[k] = v;
            }
          });
          var _onTaskReady = fileParams.onTaskReady;
          var onTaskReady = function(tid) {
            fileInfo.TaskId = tid;
            _onTaskReady && _onTaskReady(tid);
          };
          fileParams.onTaskReady = onTaskReady;
          var PreAddSize = 0;
          var _onProgress = fileParams.onProgress;
          var onProgress = function(info) {
            TotalFinish = TotalFinish - PreAddSize + info.loaded;
            PreAddSize = info.loaded;
            _onProgress && _onProgress(info);
            onTotalProgress({ loaded: TotalFinish, total: TotalSize });
          };
          fileParams.onProgress = onProgress;
          var _onFileFinish = fileParams.onFileFinish;
          var onFileFinish = function(err, data) {
            _onFileFinish && _onFileFinish(err, data);
            onTotalFileFinish && onTotalFileFinish(err, data, fileInfo);
          };
          var api = FileSize > SliceSize ? "sliceUploadFile" : "putObject";
          taskList.push({
            api,
            params: fileParams,
            callback: onFileFinish
          });
        })();
      });
      self2._addTasks(taskList);
    }
    function sliceCopyFile(params, callback) {
      var ep = new EventProxy();
      var self2 = this;
      var Bucket = params.Bucket;
      var Region = params.Region;
      var Key = params.Key;
      var CopySource = params.CopySource;
      var m = util.getSourceParams.call(this, CopySource);
      if (!m) {
        callback(util.error(new Error("CopySource format error")));
        return;
      }
      var SourceBucket = m.Bucket;
      var SourceRegion = m.Region;
      var SourceKey = decodeURIComponent(m.Key);
      var CopySliceSize = params.CopySliceSize === void 0 ? self2.options.CopySliceSize : params.CopySliceSize;
      CopySliceSize = Math.max(0, CopySliceSize);
      var ChunkSize = params.CopyChunkSize || this.options.CopyChunkSize;
      var ChunkParallel = this.options.CopyChunkParallelLimit;
      var FinishSize = 0;
      var FileSize;
      var onProgress;
      ep.on("copy_slice_complete", function(UploadData) {
        var metaHeaders = {};
        util.each(params.Headers, function(val, k) {
          if (k.toLowerCase().indexOf("x-cos-meta-") === 0)
            metaHeaders[k] = val;
        });
        var Parts = util.map(UploadData.PartList, function(item) {
          return {
            PartNumber: item.PartNumber,
            ETag: item.ETag
          };
        });
        self2.multipartComplete({
          Bucket,
          Region,
          Key,
          UploadId: UploadData.UploadId,
          Parts
        }, function(err, data) {
          if (err) {
            onProgress(null, true);
            return callback(err);
          }
          onProgress({ loaded: FileSize, total: FileSize }, true);
          callback(null, data);
        });
      });
      ep.on("get_copy_data_finish", function(UploadData) {
        Async.eachLimit(UploadData.PartList, ChunkParallel, function(SliceItem, asyncCallback) {
          var PartNumber = SliceItem.PartNumber;
          var CopySourceRange = SliceItem.CopySourceRange;
          var currentSize = SliceItem.end - SliceItem.start;
          copySliceItem.call(self2, {
            Bucket,
            Region,
            Key,
            CopySource,
            UploadId: UploadData.UploadId,
            PartNumber,
            CopySourceRange
          }, function(err, data) {
            if (err)
              return asyncCallback(err);
            FinishSize += currentSize;
            onProgress({ loaded: FinishSize, total: FileSize });
            SliceItem.ETag = data.ETag;
            asyncCallback(err || null, data);
          });
        }, function(err) {
          if (err) {
            onProgress(null, true);
            return callback(err);
          }
          ep.emit("copy_slice_complete", UploadData);
        });
      });
      ep.on("get_file_size_finish", function(SourceHeaders) {
        (function() {
          var SIZE = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 1024 * 2, 1024 * 4, 1024 * 5];
          var AutoChunkSize = 1024 * 1024;
          for (var i = 0; i < SIZE.length; i++) {
            AutoChunkSize = SIZE[i] * 1024 * 1024;
            if (FileSize / AutoChunkSize <= self2.options.MaxPartNumber)
              break;
          }
          params.ChunkSize = ChunkSize = Math.max(ChunkSize, AutoChunkSize);
          var ChunkCount = Math.ceil(FileSize / ChunkSize);
          var list = [];
          for (var partNumber = 1; partNumber <= ChunkCount; partNumber++) {
            var start = (partNumber - 1) * ChunkSize;
            var end = partNumber * ChunkSize < FileSize ? partNumber * ChunkSize - 1 : FileSize - 1;
            var item = {
              PartNumber: partNumber,
              start,
              end,
              CopySourceRange: "bytes=" + start + "-" + end
            };
            list.push(item);
          }
          params.PartList = list;
        })();
        var TargetHeader;
        if (params.Headers["x-cos-metadata-directive"] === "Replaced") {
          TargetHeader = params.Headers;
        } else {
          TargetHeader = SourceHeaders;
        }
        TargetHeader["x-cos-storage-class"] = params.Headers["x-cos-storage-class"] || SourceHeaders["x-cos-storage-class"];
        TargetHeader = util.clearKey(TargetHeader);
        if (SourceHeaders["x-cos-storage-class"] === "ARCHIVE" || SourceHeaders["x-cos-storage-class"] === "DEEP_ARCHIVE") {
          var restoreHeader = SourceHeaders["x-cos-restore"];
          if (!restoreHeader || restoreHeader === 'ongoing-request="true"') {
            callback(util.error(new Error("Unrestored archive object is not allowed to be copied")));
            return;
          }
        }
        delete TargetHeader["x-cos-copy-source"];
        delete TargetHeader["x-cos-metadata-directive"];
        delete TargetHeader["x-cos-copy-source-If-Modified-Since"];
        delete TargetHeader["x-cos-copy-source-If-Unmodified-Since"];
        delete TargetHeader["x-cos-copy-source-If-Match"];
        delete TargetHeader["x-cos-copy-source-If-None-Match"];
        self2.multipartInit({
          Bucket,
          Region,
          Key,
          Headers: TargetHeader
        }, function(err, data) {
          if (err)
            return callback(err);
          params.UploadId = data.UploadId;
          ep.emit("get_copy_data_finish", params);
        });
      });
      self2.headObject({
        Bucket: SourceBucket,
        Region: SourceRegion,
        Key: SourceKey
      }, function(err, data) {
        if (err) {
          if (err.statusCode && err.statusCode === 404) {
            callback(util.error(err, { ErrorStatus: SourceKey + " Not Exist" }));
          } else {
            callback(err);
          }
          return;
        }
        FileSize = params.FileSize = data.headers["content-length"];
        if (FileSize === void 0 || !FileSize) {
          callback(util.error(new Error('get Content-Length error, please add "Content-Length" to CORS ExposeHeader setting.\uFF08 \u83B7\u53D6Content-Length\u5931\u8D25\uFF0C\u8BF7\u5728CORS ExposeHeader\u8BBE\u7F6E\u4E2D\u6DFB\u52A0Content-Length\uFF0C\u8BF7\u53C2\u8003\u6587\u6863\uFF1Ahttps://cloud.tencent.com/document/product/436/13318 \uFF09')));
          return;
        }
        onProgress = util.throttleOnProgress.call(self2, FileSize, params.onProgress);
        if (FileSize <= CopySliceSize) {
          if (!params.Headers["x-cos-metadata-directive"]) {
            params.Headers["x-cos-metadata-directive"] = "Copy";
          }
          self2.putObjectCopy(params, function(err2, data2) {
            if (err2) {
              onProgress(null, true);
              return callback(err2);
            }
            onProgress({ loaded: FileSize, total: FileSize }, true);
            callback(err2, data2);
          });
        } else {
          var resHeaders = data.headers;
          var SourceHeaders = {
            "Cache-Control": resHeaders["cache-control"],
            "Content-Disposition": resHeaders["content-disposition"],
            "Content-Encoding": resHeaders["content-encoding"],
            "Content-Type": resHeaders["content-type"],
            "Expires": resHeaders["expires"],
            "x-cos-storage-class": resHeaders["x-cos-storage-class"]
          };
          util.each(resHeaders, function(v, k) {
            var metaPrefix = "x-cos-meta-";
            if (k.indexOf(metaPrefix) === 0 && k.length > metaPrefix.length) {
              SourceHeaders[k] = v;
            }
          });
          ep.emit("get_file_size_finish", SourceHeaders);
        }
      });
    }
    function copySliceItem(params, callback) {
      var TaskId = params.TaskId;
      var Bucket = params.Bucket;
      var Region = params.Region;
      var Key = params.Key;
      var CopySource = params.CopySource;
      var UploadId = params.UploadId;
      var PartNumber = params.PartNumber * 1;
      var CopySourceRange = params.CopySourceRange;
      var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;
      var self2 = this;
      Async.retry(ChunkRetryTimes, function(tryCallback) {
        self2.uploadPartCopy({
          TaskId,
          Bucket,
          Region,
          Key,
          CopySource,
          UploadId,
          PartNumber,
          CopySourceRange
        }, function(err, data) {
          tryCallback(err || null, data);
        });
      }, function(err, data) {
        return callback(err, data);
      });
    }
    var API_MAP = {
      sliceUploadFile,
      abortUploadTask,
      uploadFile,
      uploadFiles,
      sliceCopyFile
    };
    module2.exports.init = function(COS, task) {
      task.transferToTaskMethod(API_MAP, "sliceUploadFile");
      util.each(API_MAP, function(fn, apiName) {
        COS.prototype[apiName] = util.apiWrapper(apiName, fn);
      });
    };
  }
});

// node_modules/cos-js-sdk-v5/src/cos.js
var require_cos = __commonJS({
  "node_modules/cos-js-sdk-v5/src/cos.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var event = require_event();
    var task = require_task();
    var base = require_base();
    var advance = require_advance();
    var defaultOptions = {
      AppId: "",
      SecretId: "",
      SecretKey: "",
      SecurityToken: "",
      ChunkRetryTimes: 2,
      FileParallelLimit: 3,
      ChunkParallelLimit: 3,
      ChunkSize: 1024 * 1024,
      SliceSize: 1024 * 1024,
      CopyChunkParallelLimit: 20,
      CopyChunkSize: 1024 * 1024 * 10,
      CopySliceSize: 1024 * 1024 * 10,
      MaxPartNumber: 1e4,
      ProgressInterval: 1e3,
      Domain: "",
      ServiceDomain: "",
      Protocol: "",
      CompatibilityMode: false,
      ForcePathStyle: false,
      UseRawKey: false,
      Timeout: 0,
      CorrectClockSkew: true,
      SystemClockOffset: 0,
      UploadCheckContentMd5: false,
      UploadQueueSize: 1e4,
      UploadAddMetaMd5: false,
      UploadIdCacheLimit: 50,
      UseAccelerate: false,
      ForceSignHost: true
    };
    var COS = function(options) {
      this.options = util.extend(util.clone(defaultOptions), options || {});
      this.options.FileParallelLimit = Math.max(1, this.options.FileParallelLimit);
      this.options.ChunkParallelLimit = Math.max(1, this.options.ChunkParallelLimit);
      this.options.ChunkRetryTimes = Math.max(0, this.options.ChunkRetryTimes);
      this.options.ChunkSize = Math.max(1024 * 1024, this.options.ChunkSize);
      this.options.CopyChunkParallelLimit = Math.max(1, this.options.CopyChunkParallelLimit);
      this.options.CopyChunkSize = Math.max(1024 * 1024, this.options.CopyChunkSize);
      this.options.CopySliceSize = Math.max(0, this.options.CopySliceSize);
      this.options.MaxPartNumber = Math.max(1024, Math.min(1e4, this.options.MaxPartNumber));
      this.options.Timeout = Math.max(0, this.options.Timeout);
      if (this.options.AppId) {
        console.warn('warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g: "test-1250000000").');
      }
      if (this.options.SecretId && this.options.SecretId.indexOf(" ") > -1) {
        console.error("error: SecretId\u683C\u5F0F\u9519\u8BEF\uFF0C\u8BF7\u68C0\u67E5");
        console.error("error: SecretId format is incorrect. Please check");
      }
      if (this.options.SecretKey && this.options.SecretKey.indexOf(" ") > -1) {
        console.error("error: SecretKey\u683C\u5F0F\u9519\u8BEF\uFF0C\u8BF7\u68C0\u67E5");
        console.error("error: SecretKey format is incorrect. Please check");
      }
      if (util.isNode()) {
        console.warn("warning: cos-js-sdk-v5 \u4E0D\u652F\u6301 nodejs \u73AF\u5883\u4F7F\u7528\uFF0C\u8BF7\u6539\u7528 cos-nodejs-sdk-v5\uFF0C\u53C2\u8003\u6587\u6863\uFF1A https://cloud.tencent.com/document/product/436/8629");
        console.warn("warning: cos-js-sdk-v5 does not support nodejs environment. Please use cos-nodejs-sdk-v5 instead. See: https://cloud.tencent.com/document/product/436/8629");
      }
      event.init(this);
      task.init(this);
    };
    base.init(COS, task);
    advance.init(COS, task);
    COS.util = {
      md5: util.md5,
      xml2json: util.xml2json,
      json2xml: util.json2xml
    };
    COS.getAuthorization = util.getAuth;
    COS.version = "1.3.10";
    module2.exports = COS;
  }
});

// node_modules/cos-js-sdk-v5/index.js
var require_cos_js_sdk_v5 = __commonJS({
  "node_modules/cos-js-sdk-v5/index.js"(exports2, module2) {
    var COS = require_cos();
    module2.exports = COS;
  }
});

// dep:cos-js-sdk-v5
var cos_js_sdk_v5_default = require_cos_js_sdk_v5();
export {
  cos_js_sdk_v5_default as default
};
//# sourceMappingURL=cos-js-sdk-v5.js.map
